 .gitignore                                            | 6 +++---
 source/FreeRTOS_ARP.c                                 | 3 ++-
 source/FreeRTOS_DNS.c                                 | 4 +++-
 source/FreeRTOS_IP.c                                  | 2 +-
 source/FreeRTOS_TCP_IP.c                              | 3 ++-
 source/FreeRTOS_UDP_IP.c                              | 3 ++-
 source/portable/BufferManagement/BufferAllocation_2.c | 2 +-
 7 files changed, 14 insertions(+), 9 deletions(-)

diff --git a/.gitignore b/.gitignore
index 3084e83..a45c4da 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,3 @@
-**/*.d
-**/*.o
-**/*.su
+**/Debug/
+**/Release/
+
diff --git a/source/FreeRTOS_ARP.c b/source/FreeRTOS_ARP.c
index 20aff6b..d4b2526 100644
--- a/source/FreeRTOS_ARP.c
+++ b/source/FreeRTOS_ARP.c
@@ -168,6 +168,7 @@ eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
     /* Introduce a do while loop to allow use of breaks. */
     do
     {
+		uint32_t ulHostEndianProtocolAddr;
         /* Only Ethernet hardware type is supported.
          * Only IPv4 address can be present in the ARP packet.
          * The hardware length (the MAC address) must be 6 bytes. And,
@@ -193,7 +194,7 @@ eFrameProcessingResult_t eARPProcessPacket( ARPPacket_t * const pxARPFrame )
             break;
         }
 
-        uint32_t ulHostEndianProtocolAddr = FreeRTOS_ntohl( ulSenderProtocolAddress );
+       ulHostEndianProtocolAddr = FreeRTOS_ntohl( ulSenderProtocolAddress );
 
         if( ( ipFIRST_LOOPBACK_IPv4 <= ulHostEndianProtocolAddr ) &&
             ( ulHostEndianProtocolAddr < ipLAST_LOOPBACK_IPv4 ) )
diff --git a/source/FreeRTOS_DNS.c b/source/FreeRTOS_DNS.c
index 87ca5c9..b0d6852 100644
--- a/source/FreeRTOS_DNS.c
+++ b/source/FreeRTOS_DNS.c
@@ -394,6 +394,7 @@
 
         /* Obtain the DNS server address. */
         FreeRTOS_GetAddressConfiguration( NULL, NULL, NULL, &ulIPAddress );
+		{
         #if ( ipconfigUSE_LLMNR == 1 )
             BaseType_t bHasDot = llmnr_has_dot( pcHostName );
 
@@ -412,6 +413,7 @@
             pxAddress->sin_port = dnsDNS_PORT;
         }
     }
+    }
 
 /*!
  * @brief return ip address from the dns reply message
@@ -579,7 +581,7 @@
                                                   TickType_t uxIdentifier,
                                                   Socket_t xDNSSocket )
     {
-        uint32_t ulIPAddress;
+        uint32_t ulIPAddress = 0U;
         BaseType_t xAttempt;
 
         for( xAttempt = 0; xAttempt < ipconfigDNS_REQUEST_ATTEMPTS; xAttempt++ )
diff --git a/source/FreeRTOS_IP.c b/source/FreeRTOS_IP.c
index 8efbbf5..7950b58 100644
--- a/source/FreeRTOS_IP.c
+++ b/source/FreeRTOS_IP.c
@@ -999,9 +999,9 @@ void FreeRTOS_ReleaseUDPPayloadBuffer( void const * pvBuffer )
         uint8_t * pucChar;
         size_t uxTotalLength;
         IPStackEvent_t xStackTxEvent = { eStackTxEvent, NULL };
+        BaseType_t xEnoughSpace;
 
         uxTotalLength = uxNumberOfBytesToSend + sizeof( ICMPPacket_t );
-        BaseType_t xEnoughSpace;
 
         if( uxNumberOfBytesToSend < ( ipconfigNETWORK_MTU - ( sizeof( IPHeader_t ) + sizeof( ICMPHeader_t ) ) ) )
         {
diff --git a/source/FreeRTOS_TCP_IP.c b/source/FreeRTOS_TCP_IP.c
index 1b9451d..980c387 100644
--- a/source/FreeRTOS_TCP_IP.c
+++ b/source/FreeRTOS_TCP_IP.c
@@ -621,7 +621,7 @@
 
         configASSERT( pxNetworkBuffer != NULL );
         configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
-
+{
         /* Map the buffer onto a ProtocolHeaders_t struct for easy access to the fields. */
 
         /* MISRA Ref 11.3.1 [Misaligned access] */
@@ -863,6 +863,7 @@
 
         /* pdPASS being returned means the buffer has been consumed. */
         return xResult;
+	}
     }
     /*-----------------------------------------------------------*/
 
diff --git a/source/FreeRTOS_UDP_IP.c b/source/FreeRTOS_UDP_IP.c
index d8819da..be38bdb 100644
--- a/source/FreeRTOS_UDP_IP.c
+++ b/source/FreeRTOS_UDP_IP.c
@@ -315,7 +315,7 @@ BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t * pxNetworkBuffe
     configASSERT( pxNetworkBuffer->pucEthernetBuffer != NULL );
 
     /* Map the ethernet buffer to the UDPPacket_t struct for easy access to the fields. */
-
+{
     /* MISRA Ref 11.3.1 [Misaligned access] */
 /* More details at: https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/blob/main/MISRA.md#rule-113 */
     /* coverity[misra_c_2012_rule_11_3_violation] */
@@ -498,4 +498,5 @@ BaseType_t xProcessReceivedUDPPacket( NetworkBufferDescriptor_t * pxNetworkBuffe
 
     return xReturn;
 }
+}
 /*-----------------------------------------------------------*/
diff --git a/source/portable/BufferManagement/BufferAllocation_2.c b/source/portable/BufferManagement/BufferAllocation_2.c
index bd8db4c..0abdaad 100644
--- a/source/portable/BufferManagement/BufferAllocation_2.c
+++ b/source/portable/BufferManagement/BufferAllocation_2.c
@@ -73,7 +73,7 @@
     #define ASSERT_CONCAT_( a, b )    a ## b
     #define ASSERT_CONCAT( a, b )     ASSERT_CONCAT_( a, b )
     #define STATIC_ASSERT( e ) \
-    ; enum { ASSERT_CONCAT( assert_line_, __LINE__ ) = 1 / ( !!( e ) ) }
+    enum { ASSERT_CONCAT( assert_line_, __LINE__ ) = 1 / ( !!( e ) ) }
 
     STATIC_ASSERT( ipconfigETHERNET_MINIMUM_PACKET_BYTES <= baMINIMAL_BUFFER_SIZE );
 #endif