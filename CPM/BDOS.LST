   1:					include CPM.INC
**** ./CPM22/CPM.INC ****
   1:				
   2:				;	CBIOS for eZ80 Z80-Mixed-Mode
   3:				;
   4:				;	Copyright (C) 1998-2021 by Juergen Sievers
   5:				;
   6:     -	0040          	MEM:		EQU	64	;cp/m version memory size in kilobytes
   7:				;
   8:				;	"bias" is address offset from 3400H for memory systems
   9:				;	than 16K (referred to as "b" throughout the text).
  10:				;
  11:     -	B000          	BIAS:	EQU	(MEM-20)*1024
  12:     -	E400          	CCP:	EQU	3400H+BIAS	;base of ccp
  13:     -	EC06          	BDOS:	EQU	CCP+806H	;base of bdos
  14:     -	FA00          	BIOS:	EQU	CCP+1600H	;base of bios
  15:     -	0004          	CDISK:	EQU	0004H		;current disk number 0=A,...,15=P
  16:				
  17:				;
  18:				;   BIOS entrys
  19:				;
  20:     -	FA00          	BOOT 	equ BIOS+3*0   ;cold start
  21:     -	FA03          	WBOOT 	equ BIOS+3*1   ;warm start
  22:     -	FA06          	CONST 	equ BIOS+3*2   ;console status
  23:     -	FA09          	CONIN 	equ BIOS+3*3   ;console character in
  24:     -	FA0C          	CONOUT  equ BIOS+3*4   ;console character out
  25:     -	FA0F          	PLIST 	equ BIOS+3*5   ;list character out
  26:     -	FA12          	PUNCH 	equ BIOS+3*6   ;punch character out
  27:     -	FA15          	READER  equ BIOS+3*7   ;reader character out
  28:     -	FA18          	HOME 	equ BIOS+3*8   ;move head to home position
  29:     -	FA1B          	SELDSK  equ BIOS+3*9   ;select disk
  30:     -	FA1E          	SETTRK  equ BIOS+3*10  ;set track number
  31:     -	FA21          	SETSEC  equ BIOS+3*11  ;set sector number
  32:     -	FA24          	SETDMA  equ BIOS+3*12  ;set dma address
  33:     -	FA27          	READ 	equ BIOS+3*13  ;read disk
  34:     -	FA2A          	WRITE 	equ BIOS+3*14  ;write disk
  35:     -	FA2D          	LISTST  equ BIOS+3*15  ;return list status
  36:     -	FA30          	SECTRN  equ BIOS+3*16  ;sector translate
  37:				
  38:				;
  39:				;   Set control character equates.
  40:				;
  41:     -	0003          	CNTRLC	EQU	3		;control-c
  42:     -	0005          	CNTRLE	EQU	05H		;control-e
  43:     -	0008          	BS		EQU	08H		;backspace
  44:     -	0009          	TAB		EQU	09H		;tab
  45:     -	000A          	LF		EQU	0AH		;line feed
  46:     -	000C          	FF		EQU	0CH		;form feed
  47:     -	000D          	CR		EQU	0DH		;carriage return
  48:     -	0010          	CNTRLP	EQU	10H		;control-p
  49:     -	0012          	CNTRLR	EQU	12H		;control-r
  50:     -	0013          	CNTRLS	EQU	13H		;control-s
  51:     -	0015          	CNTRLU	EQU	15H		;control-u
  52:     -	0018          	CNTRLX	EQU	18H		;control-x
  53:     -	001A          	CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
  54:     -	007F          	DEL		EQU	7FH		;rubout
  55:				
  56:     -	0003          	IOBYTE	EQU	3		;i/o definition byte.
  57:     -	0004          	TDRIVE	EQU	4		;current drive name and user number.
  58:     -	0005          	ENTRY	EQU	5		;entry point for the cp/m bdos.
  59:     -	005C          	TFCB	EQU	5CH		;default file control block.
  60:     -	0080          	TBUFF	EQU	80H		;i/o buffer and command line storage.
  61:     -	0100          	TBASE	EQU	100H		;transiant program storage area.
  62:				
  63:				
  64:				SERIALNO macro
  65:						db	0,22,0,0,0,0
  66:						endm
**** ./CPM22/BDOS.ASM ****
   2:				
   3:     -	EC00          		ORG	BDOS-6
   4:				
   5:				;
   6:				;   Note that the following six bytes must match those at
   7:				; (PATTRN1) or cp/m will HALT. Why?
   8:				;
   9:     -	EC00          	PATTRN2: SERIALNO	;(* serial number bytes *).
   9:     -	EC00  00160000			db	0,22,0,0,0,0
	              0000
   9:     -	EC06          			endm
  10:				;
  11:				;**************************************************************
  12:				;*
  13:				;*                    B D O S   E N T R Y
  14:				;*
  15:				;**************************************************************
  16:				;
  17:    0+10	EC06  C311EC  	FBASE:	JP	FBASE1
  18:				;
  19:				;   Bdos error table.
  20:				;
  21:     -	EC09  99EC    	BADSCTR:DW	ERROR1		;bad sector on read or write.
  22:     -	EC0B  A5EC    	BADSLCT:DW	ERROR2		;bad disk select.
  23:     -	EC0D  ABEC    	RODISK:	DW	ERROR3		;disk is read only.
  24:     -	EC0F  B1EC    	ROFILE:	DW	ERROR4		;file is read only.
  25:				;
  26:				;   Entry into bdos. (DE) or (E) are the parameters passed. The
  27:				; function number desired is in register (C).
  28:				;
  29:   10+4	EC11  EB      	FBASE1:	EX	DE,HL		;save the (DE) parameters.
  30:   14+16	EC12  2243EF  		LD	(PARAMS),HL
  31:   30+4	EC15  EB      		EX	DE,HL
  32:   34+4	EC16  7B      		LD	A,E		;and save register (E) in particular.
  33:   38+13	EC17  32D6F9  		LD	(EPARAM),A
  34:   51+10	EC1A  210000  		LD	HL,0
  35:   61+16	EC1D  2245EF  		LD	(STATUS),HL	;clear return status.
  36:   77+11	EC20  39      		ADD	HL,SP
  37:   88+16	EC21  220FEF  		LD	(USRSTACK),HL	;save users stack pointer.
  38:  104+10	EC24  3141EF  		LD	SP,STKAREA	;and set our own.
  39:  114+4	EC27  AF      		XOR	A		;clear auto select storage space.
  40:  118+13	EC28  32E0F9  		LD	(AUTOFLAG),A
  41:  131+13	EC2B  32DEF9  		LD	(AUTO),A
  42:  144+10	EC2E  2174F9  		LD	HL,GOBACK	;set return address.
  43:  154+11	EC31  E5      		PUSH	HL
  44:  165+4	EC32  79      		LD	A,C		;get function number.
  45:  169+7	EC33  FE29    		CP	NFUNCTS		;valid function number?
  46:  176+5+6	EC35  D0      		RET	NC
  47:  181+4	EC36  4B      		LD	C,E		;keep single register function here.
  48:  185+10	EC37  2147EC  		LD	HL,FUNCTNS	;now look thru the function table.
  49:  195+4	EC3A  5F      		LD	E,A
  50:  199+7	EC3B  1600    		LD	D,0		;(DE)=function number.
  51:  206+11	EC3D  19      		ADD	HL,DE
  52:  217+11	EC3E  19      		ADD	HL,DE		;(HL)=(start of table)+2*(function number).
  53:  228+7	EC3F  5E      		LD	E,(HL)
  54:  235+6	EC40  23      		INC	HL
  55:  241+7	EC41  56      		LD	D,(HL)		;now (DE)=address for this function.
  56:  248+16	EC42  2A43EF  		LD	HL,(PARAMS)	;retrieve parameters.
  57:  264+4	EC45  EB      		EX	DE,HL		;now (DE) has the original parameters.
  58:  268+4	EC46  E9      		JP	(HL)		;execute desired function.
  59:				;
  60:				;   BDOS function jump table.
  61:				;
  62:     -	0029          	NFUNCTS EQU	41		;number of functions in followin table.
  63:				;
  64:     -	EC47  03FAC8EE	FUNCTNS:DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
	              90EDCEEE
	              12FA0000
	              D4EEEDEE
  65:     -	EC57  F3EEF8EE		DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
	              E1EDFEEE
	              7EF883F8
	              45F89CF8
  66:     -	EC67  A5F8ABF8		DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
	              C8F8D7F8
	              E0F8E6F8
	              ECF8
  67:     -	EC75  F5F8FEF8		DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
	              04F90AF9
	              11F92CF1
	              17F91DF9
  68:     -	EC85  26F92DF9		DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
	              41F947F9
	              4DF90EF8
	              53F904EF
  69:     -	EC95  04EF9BF9		DW	RTN,WTSPECL
  70:				;
  71:				;   Bdos error message section.
  72:				;
  73:  272+10	EC99  21CAEC  	ERROR1:	LD	HL,BADSEC	;bad sector message.
  74:  282+17	EC9C  CDE5EC  		CALL	PRTERR		;print it and get a 1 char responce.
  75:  299+7	EC9F  FE03    		CP	CNTRLC		;re-boot request (control-c)?
  76:  306+10	ECA1  CA0000  		JP	Z,0		;yes.
  77:  316+10	ECA4  C9      		RET			;no, return to retry i/o function.
  78:				;
  79:  326+10	ECA5  21D5EC  	ERROR2:	LD	HL,BADSEL	;bad drive selected.
  80:  336+10	ECA8  C3B4EC  		JP	ERROR5
  81:				;
  82:  346+10	ECAB  21E1EC  	ERROR3:	LD	HL,DISKRO	;disk is read only.
  83:  356+10	ECAE  C3B4EC  		JP	ERROR5
  84:				;
  85:  366+10	ECB1  21DCEC  	ERROR4:	LD	HL,FILERO	;file is read only.
  86:				;
  87:  376+17	ECB4  CDE5EC  	ERROR5:	CALL	PRTERR
  88:  393+10	ECB7  C30000  		JP	0		;always reboot on these errors.
  89:				;
  90:     -	ECBA  42646F73	BDOSERR:DEFB	'Bdos Err On '
	              20457272
	              204F6E20
  91:     -	ECC6  203A2024	BDOSDRV:DEFB	' : $'
  92:     -	ECCA  42616420	BADSEC:	DEFB	'Bad Sector$'
	              53656374
	              6F7224
  93:     -	ECD5  53656C65	BADSEL:	DEFB	'Select$'
	              637424
  94:     -	ECDC  46696C65	FILERO:	DEFB	'File '
	              20
  95:     -	ECE1  522F4F24	DISKRO:	DEFB	'R/O$'
  96:				;
  97:				;   Print bdos error message.
  98:				;
  99:  403+11	ECE5  E5      	PRTERR:	PUSH	HL		;save second message pointer.
 100:  414+17	ECE6  CDC9ED  		CALL	OUTCRLF		;send (cr)(lf).
 101:  431+13	ECE9  3A42EF  		LD	A,(ACTIVE)	;get active drive.
 102:  444+7	ECEC  C641    		ADD	A,'A'		;make ascii.
 103:  451+13	ECEE  32C6EC  		LD	(BDOSDRV),A	;and put in message.
 104:  464+10	ECF1  01BAEC  		LD	BC,BDOSERR	;and print it.
 105:  474+17	ECF4  CDD3ED  		CALL	PRTMESG
 106:  491+10	ECF7  C1      		POP	BC		;print second message line now.
 107:  501+17	ECF8  CDD3ED  		CALL	PRTMESG
 108:				;
 109:				;   Get an input character. We will check our 1 character
 110:				; buffer first. This may be set by the console status routine.
 111:				;
 112:  518+10	ECFB  210EEF  	GETCHAR:LD	HL,CHARBUF	;check character buffer.
 113:  528+7	ECFE  7E      		LD	A,(HL)		;anything present already?
 114:  535+10	ECFF  3600    		LD	(HL),0		;...either case clear it.
 115:  545+4	ED01  B7      		OR	A
 116:  549+5+6	ED02  C0      		RET	NZ		;yes, use it.
 117:  554+10	ED03  C309FA  		JP	CONIN		;nope, go get a character responce.
 118:				;
 119:				;   Input and echo a character.
 120:				;
 121:  564+17	ED06  CDFBEC  	GETECHO:CALL	GETCHAR		;input a character.
 122:  581+17	ED09  CD14ED  		CALL	CHKCHAR		;carriage control?
 123:  598+5+6	ED0C  D8      		RET	C		;no, a regular control char so don't echo.
 124:  603+11	ED0D  F5      		PUSH	AF		;ok, save character now.
 125:  614+4	ED0E  4F      		LD	C,A
 126:  618+17	ED0F  CD90ED  		CALL	OUTCON		;and echo it.
 127:  635+10	ED12  F1      		POP	AF		;get character and return.
 128:  645+10	ED13  C9      		RET
 129:				;
 130:				;   Check character in (A). Set the zero flag on a carriage
 131:				; control character and the carry flag on any other control
 132:				; character.
 133:				;
 134:  655+7	ED14  FE0D    	CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
 135:  662+5+6	ED16  C8      		RET	Z		;or a tab.
 136:  667+7	ED17  FE0A    		CP	LF
 137:  674+5+6	ED19  C8      		RET	Z
 138:  679+7	ED1A  FE09    		CP	TAB
 139:  686+5+6	ED1C  C8      		RET	Z
 140:  691+7	ED1D  FE08    		CP	BS
 141:  698+5+6	ED1F  C8      		RET	Z
 142:  703+7	ED20  FE20    		CP	' '		;other control char? Set carry flag.
 143:  710+10	ED22  C9      		RET
 144:				;
 145:				;   Check the console during output. Halt on a control-s, then
 146:				; reboot on a control-c. If anything else is ready, clear the
 147:				; zero flag and return (the calling routine may want to do
 148:				; something).
 149:				;
 150:  720+13	ED23  3A0EEF  	CKCONSOL: LD	A,(CHARBUF)	;check buffer.
 151:  733+4	ED26  B7      		OR	A		;if anything, just return without checking.
 152:  737+10	ED27  C245ED  		JP	NZ,CKCON2
 153:  747+17	ED2A  CD06FA  		CALL	CONST		;nothing in buffer. Check console.
 154:  764+7	ED2D  E601    		AND	01H		;look at bit 0.
 155:  771+5+6	ED2F  C8      		RET	Z		;return if nothing.
 156:  776+17	ED30  CD09FA  		CALL	CONIN		;ok, get it.
 157:  793+7	ED33  FE13    		CP	CNTRLS		;if not control-s, return with zero cleared.
 158:  800+10	ED35  C242ED  		JP	NZ,CKCON1
 159:  810+17	ED38  CD09FA  		CALL	CONIN		;halt processing until another char
 160:  827+7	ED3B  FE03    		CP	CNTRLC		;is typed. Control-c?
 161:  834+10	ED3D  CA0000  		JP	Z,0		;yes, reboot now.
 162:  844+4	ED40  AF      		XOR	A		;no, just pretend nothing was ever ready.
 163:  848+10	ED41  C9      		RET
 164:  858+13	ED42  320EEF  	CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
 165:  871+7	ED45  3E01    	CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
 166:  878+10	ED47  C9      		RET
 167:				;
 168:				;   Output (C) to the screen. If the printer flip-flop flag
 169:				; is set, we will send character to printer also. The console
 170:				; will be checked in the process.
 171:				;
 172:  888+13	ED48  3A0AEF  	OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
 173:  901+4	ED4B  B7      		OR	A		;anything and we won't generate output.
 174:  905+10	ED4C  C262ED  		JP	NZ,OUTCHR1
 175:  915+11	ED4F  C5      		PUSH	BC
 176:  926+17	ED50  CD23ED  		CALL	CKCONSOL	;check console (we don't care whats there).
 177:  943+10	ED53  C1      		POP	BC
 178:  953+11	ED54  C5      		PUSH	BC
 179:  964+17	ED55  CD0CFA  		CALL	CONOUT		;output (C) to the screen.
 180:  981+10	ED58  C1      		POP	BC
 181:  991+11	ED59  C5      		PUSH	BC
 182: 1002+13	ED5A  3A0DEF  		LD	A,(PRTFLAG)	;check printer flip-flop flag.
 183: 1015+4	ED5D  B7      		OR	A
 184: 1019+10+7	ED5E  C40000  		CALL	NZ,LIST		;print it also if non-zero.
 185: 1029+10	ED61  C1      		POP	BC
 186: 1039+4	ED62  79      	OUTCHR1:LD	A,C		;update cursors position.
 187: 1043+10	ED63  210CEF  		LD	HL,CURPOS
 188: 1053+7	ED66  FE7F    		CP	DEL		;rubouts don't do anything here.
 189: 1060+5+6	ED68  C8      		RET	Z
 190: 1065+11	ED69  34      		INC	(HL)		;bump line pointer.
 191: 1076+7	ED6A  FE20    		CP	' '		;and return if a normal character.
 192: 1083+5+6	ED6C  D0      		RET	NC
 193: 1088+11	ED6D  35      		DEC	(HL)		;restore and check for the start of the line.
 194: 1099+7	ED6E  7E      		LD	A,(HL)
 195: 1106+4	ED6F  B7      		OR	A
 196: 1110+5+6	ED70  C8      		RET	Z		;ingnore control characters at the start of the line.
 197: 1115+4	ED71  79      		LD	A,C
 198: 1119+7	ED72  FE08    		CP	BS		;is it a backspace?
 199: 1126+10	ED74  C279ED  		JP	NZ,OUTCHR2
 200: 1136+11	ED77  35      		DEC	(HL)		;yes, backup pointer.
 201: 1147+10	ED78  C9      		RET
 202: 1157+7	ED79  FE0A    	OUTCHR2:CP	LF		;is it a line feed?
 203: 1164+5+6	ED7B  C0      		RET	NZ		;ignore anything else.
 204: 1169+10	ED7C  3600    		LD	(HL),0		;reset pointer to start of line.
 205: 1179+10	ED7E  C9      		RET
 206:				;
 207:				;   Output (A) to the screen. If it is a control character
 208:				; (other than carriage control), use ^x format.
 209:				;
 210: 1189+4	ED7F  79      	SHOWIT:	LD	A,C
 211: 1193+17	ED80  CD14ED  		CALL	CHKCHAR		;check character.
 212: 1210+10	ED83  D290ED  		JP	NC,OUTCON	;not a control, use normal output.
 213: 1220+11	ED86  F5      		PUSH	AF
 214: 1231+7	ED87  0E5E    		LD	C,'^'		;for a control character, preceed it with '^'.
 215: 1238+17	ED89  CD48ED  		CALL	OUTCHAR
 216: 1255+10	ED8C  F1      		POP	AF
 217: 1265+7	ED8D  F640    		OR	'@'		;and then use the letter equivelant.
 218: 1272+4	ED8F  4F      		LD	C,A
 219:				;
 220:				;   Function to output (C) to the console device and expand tabs
 221:				; if necessary.
 222:				;
 223: 1276+4	ED90  79      	OUTCON:	LD	A,C
 224: 1280+7	ED91  FE09    		CP	TAB		;is it a tab?
 225: 1287+10	ED93  C248ED  		JP	NZ,OUTCHAR	;use regular output.
 226: 1297+7	ED96  0E20    	OUTCON1:LD	C,' '		;yes it is, use spaces instead.
 227: 1304+17	ED98  CD48ED  		CALL	OUTCHAR
 228: 1321+13	ED9B  3A0CEF  		LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
 229:				
 230: 1334+7	ED9E  E607    		AND	07H		;position.
 231: 1341+10	EDA0  C296ED  		JP	NZ,OUTCON1
 232: 1351+10	EDA3  C9      		RET
 233:				;
 234:				;   Echo a backspace character. Erase the prevoius character
 235:				; on the screen.
 236:				;
 237: 1361+17	EDA4  CDACED  	BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
 238: 1378+7	EDA7  0E20    		LD	C,' '		;then blank that character.
 239: 1385+17	EDA9  CD0CFA  		CALL	CONOUT
 240: 1402+7	EDAC  0E08    	BACKUP1:LD	C,BS		;then back space once more.
 241: 1409+10	EDAE  C30CFA  		JP	CONOUT
 242:				;
 243:				;   Signal a deleted line. Print a '#' at the end and start
 244:				; over.
 245:				;
 246: 1419+7	EDB1  0E23    	NEWLINE:LD	C,'#'
 247: 1426+17	EDB3  CD48ED  		CALL	OUTCHAR		;print this.
 248: 1443+17	EDB6  CDC9ED  		CALL	OUTCRLF		;start new line.
 249: 1460+13	EDB9  3A0CEF  	NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
 250: 1473+10	EDBC  210BEF  		LD	HL,STARTING
 251: 1483+7	EDBF  BE      		CP	(HL)
 252: 1490+5+6	EDC0  D0      		RET	NC		;there yet?
 253: 1495+7	EDC1  0E20    		LD	C,' '
 254: 1502+17	EDC3  CD48ED  		CALL	OUTCHAR		;nope, keep going.
 255: 1519+10	EDC6  C3B9ED  		JP	NEWLN1
 256:				;
 257:				;   Output a (cr) (lf) to the console device (screen).
 258:				;
 259: 1529+7	EDC9  0E0D    	OUTCRLF:LD	C,CR
 260: 1536+17	EDCB  CD48ED  		CALL	OUTCHAR
 261: 1553+7	EDCE  0E0A    		LD	C,LF
 262: 1560+10	EDD0  C348ED  		JP	OUTCHAR
 263:				;
 264:				;   Print message pointed to by (BC). It will end with a '$'.
 265:				;
 266: 1570+7	EDD3  0A      	PRTMESG:LD	A,(BC)		;check for terminating character.
 267: 1577+7	EDD4  FE24    		CP	'$'
 268: 1584+5+6	EDD6  C8      		RET	Z
 269: 1589+6	EDD7  03      		INC	BC
 270: 1595+11	EDD8  C5      		PUSH	BC		;otherwise, bump pointer and print it.
 271: 1606+4	EDD9  4F      		LD	C,A
 272: 1610+17	EDDA  CD90ED  		CALL	OUTCON
 273: 1627+10	EDDD  C1      		POP	BC
 274: 1637+10	EDDE  C3D3ED  		JP	PRTMESG
 275:				;
 276:				;   Function to execute a buffered read.
 277:				;
 278: 1647+13	EDE1  3A0CEF  	RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
 279: 1660+13	EDE4  320BEF  		LD	(STARTING),A
 280: 1673+16	EDE7  2A43EF  		LD	HL,(PARAMS)	;get the maximum buffer space.
 281: 1689+7	EDEA  4E      		LD	C,(HL)
 282: 1696+6	EDEB  23      		INC	HL		;point to first available space.
 283: 1702+11	EDEC  E5      		PUSH	HL		;and save.
 284: 1713+7	EDED  0600    		LD	B,0		;keep a character count.
 285: 1720+11	EDEF  C5      	RDBUF1:	PUSH	BC
 286: 1731+11	EDF0  E5      		PUSH	HL
 287: 1742+17	EDF1  CDFBEC  	RDBUF2:	CALL	GETCHAR		;get the next input character.
 288: 1759+7	EDF4  E67F    		AND	7FH		;strip bit 7.
 289: 1766+10	EDF6  E1      		POP	HL		;reset registers.
 290: 1776+10	EDF7  C1      		POP	BC
 291: 1786+7	EDF8  FE0D    		CP	CR		;en of the line?
 292: 1793+10	EDFA  CAC1EE  		JP	Z,RDBUF17
 293: 1803+7	EDFD  FE0A    		CP	LF
 294: 1810+10	EDFF  CAC1EE  		JP	Z,RDBUF17
 295: 1820+7	EE02  FE08    		CP	BS		;how about a backspace?
 296: 1827+10	EE04  C216EE  		JP	NZ,RDBUF3
 297: 1837+4	EE07  78      		LD	A,B		;yes, but ignore at the beginning of the line.
 298: 1841+4	EE08  B7      		OR	A
 299: 1845+10	EE09  CAEFED  		JP	Z,RDBUF1
 300: 1855+4	EE0C  05      		DEC	B		;ok, update counter.
 301: 1859+13	EE0D  3A0CEF  		LD	A,(CURPOS)	;if we backspace to the start of the line,
 302: 1872+13	EE10  320AEF  		LD	(OUTFLAG),A	;treat as a cancel (control-x).
 303: 1885+10	EE13  C370EE  		JP	RDBUF10
 304: 1895+7	EE16  FE7F    	RDBUF3:	CP	DEL		;user typed a rubout?
 305: 1902+10	EE18  C226EE  		JP	NZ,RDBUF4
 306: 1912+4	EE1B  78      		LD	A,B		;ignore at the start of the line.
 307: 1916+4	EE1C  B7      		OR	A
 308: 1920+10	EE1D  CAEFED  		JP	Z,RDBUF1
 309: 1930+7	EE20  7E      		LD	A,(HL)		;ok, echo the prevoius character.
 310: 1937+4	EE21  05      		DEC	B		;and reset pointers (counters).
 311: 1941+6	EE22  2B      		DEC	HL
 312: 1947+10	EE23  C3A9EE  		JP	RDBUF15
 313: 1957+7	EE26  FE05    	RDBUF4:	CP	CNTRLE		;physical end of line?
 314: 1964+10	EE28  C237EE  		JP	NZ,RDBUF5
 315: 1974+11	EE2B  C5      		PUSH	BC		;yes, do it.
 316: 1985+11	EE2C  E5      		PUSH	HL
 317: 1996+17	EE2D  CDC9ED  		CALL	OUTCRLF
 318: 2013+4	EE30  AF      		XOR	A		;and update starting position.
 319: 2017+13	EE31  320BEF  		LD	(STARTING),A
 320: 2030+10	EE34  C3F1ED  		JP	RDBUF2
 321: 2040+7	EE37  FE10    	RDBUF5:	CP	CNTRLP		;control-p?
 322: 2047+10	EE39  C248EE  		JP	NZ,RDBUF6
 323: 2057+11	EE3C  E5      		PUSH	HL		;yes, flip the print flag filp-flop byte.
 324: 2068+10	EE3D  210DEF  		LD	HL,PRTFLAG
 325: 2078+7	EE40  3E01    		LD	A,1		;PRTFLAG=1-PRTFLAG
 326: 2085+7	EE42  96      		SUB	(HL)
 327: 2092+7	EE43  77      		LD	(HL),A
 328: 2099+10	EE44  E1      		POP	HL
 329: 2109+10	EE45  C3EFED  		JP	RDBUF1
 330: 2119+7	EE48  FE18    	RDBUF6:	CP	CNTRLX		;control-x (cancel)?
 331: 2126+10	EE4A  C25FEE  		JP	NZ,RDBUF8
 332: 2136+10	EE4D  E1      		POP	HL
 333: 2146+13	EE4E  3A0BEF  	RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
 334: 2159+10	EE51  210CEF  		LD	HL,CURPOS
 335: 2169+7	EE54  BE      		CP	(HL)
 336: 2176+10	EE55  D2E1ED  		JP	NC,RDBUFF	;done yet?
 337: 2186+11	EE58  35      		DEC	(HL)		;no, decrement pointer and output back up one space.
 338: 2197+17	EE59  CDA4ED  		CALL	BACKUP
 339: 2214+10	EE5C  C34EEE  		JP	RDBUF7
 340: 2224+7	EE5F  FE15    	RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
 341: 2231+10	EE61  C26BEE  		JP	NZ,RDBUF9
 342: 2241+17	EE64  CDB1ED  		CALL	NEWLINE		;start a new line.
 343: 2258+10	EE67  E1      		POP	HL
 344: 2268+10	EE68  C3E1ED  		JP	RDBUFF
 345: 2278+7	EE6B  FE12    	RDBUF9:	CP	CNTRLR		;control-r?
 346: 2285+10	EE6D  C2A6EE  		JP	NZ,RDBUF14
 347: 2295+11	EE70  C5      	RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
 348: 2306+17	EE71  CDB1ED  		CALL	NEWLINE
 349: 2323+10	EE74  C1      		POP	BC
 350: 2333+10	EE75  E1      		POP	HL
 351: 2343+11	EE76  E5      		PUSH	HL
 352: 2354+11	EE77  C5      		PUSH	BC
 353: 2365+4	EE78  78      	RDBUF11:LD	A,B		;done whole line yet?
 354: 2369+4	EE79  B7      		OR	A
 355: 2373+10	EE7A  CA8AEE  		JP	Z,RDBUF12
 356: 2383+6	EE7D  23      		INC	HL		;nope, get next character.
 357: 2389+7	EE7E  4E      		LD	C,(HL)
 358: 2396+4	EE7F  05      		DEC	B		;count it.
 359: 2400+11	EE80  C5      		PUSH	BC
 360: 2411+11	EE81  E5      		PUSH	HL
 361: 2422+17	EE82  CD7FED  		CALL	SHOWIT		;and display it.
 362: 2439+10	EE85  E1      		POP	HL
 363: 2449+10	EE86  C1      		POP	BC
 364: 2459+10	EE87  C378EE  		JP	RDBUF11
 365: 2469+11	EE8A  E5      	RDBUF12:PUSH	HL		;done with line. If we were displaying
 366: 2480+13	EE8B  3A0AEF  		LD	A,(OUTFLAG)	;then update cursor position.
 367: 2493+4	EE8E  B7      		OR	A
 368: 2497+10	EE8F  CAF1ED  		JP	Z,RDBUF2
 369: 2507+10	EE92  210CEF  		LD	HL,CURPOS	;because this line is shorter, we must
 370: 2517+7	EE95  96      		SUB	(HL)		;back up the cursor (not the screen however)
 371: 2524+13	EE96  320AEF  		LD	(OUTFLAG),A	;some number of positions.
 372: 2537+17	EE99  CDA4ED  	RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
 373: 2554+10	EE9C  210AEF  		LD	HL,OUTFLAG	;zero, the screen will not be changed.
 374: 2564+11	EE9F  35      		DEC	(HL)
 375: 2575+10	EEA0  C299EE  		JP	NZ,RDBUF13
 376: 2585+10	EEA3  C3F1ED  		JP	RDBUF2		;now just get the next character.
 377:				;
 378:				;   Just a normal character, put this in our buffer and echo.
 379:				;
 380: 2595+6	EEA6  23      	RDBUF14:INC	HL
 381: 2601+7	EEA7  77      		LD	(HL),A		;store character.
 382: 2608+4	EEA8  04      		INC	B		;and count it.
 383: 2612+11	EEA9  C5      	RDBUF15:PUSH	BC
 384: 2623+11	EEAA  E5      		PUSH	HL
 385: 2634+4	EEAB  4F      		LD	C,A		;echo it now.
 386: 2638+17	EEAC  CD7FED  		CALL	SHOWIT
 387: 2655+10	EEAF  E1      		POP	HL
 388: 2665+10	EEB0  C1      		POP	BC
 389: 2675+7	EEB1  7E      		LD	A,(HL)		;was it an abort request?
 390: 2682+7	EEB2  FE03    		CP	CNTRLC		;control-c abort?
 391: 2689+4	EEB4  78      		LD	A,B
 392: 2693+10	EEB5  C2BDEE  		JP	NZ,RDBUF16
 393: 2703+7	EEB8  FE01    		CP	1		;only if at start of line.
 394: 2710+10	EEBA  CA0000  		JP	Z,0
 395: 2720+4	EEBD  B9      	RDBUF16:CP	C		;nope, have we filled the buffer?
 396: 2724+10	EEBE  DAEFED  		JP	C,RDBUF1
 397: 2734+10	EEC1  E1      	RDBUF17:POP	HL		;yes end the line and return.
 398: 2744+7	EEC2  70      		LD	(HL),B
 399: 2751+7	EEC3  0E0D    		LD	C,CR
 400: 2758+10	EEC5  C348ED  		JP	OUTCHAR		;output (cr) and return.
 401:				;
 402:				;   Function to get a character from the console device.
 403:				;
 404: 2768+17	EEC8  CD06ED  	GETCON:	CALL	GETECHO		;get and echo.
 405: 2785+10	EECB  C301EF  		JP	SETSTAT		;save status and return.
 406:				;
 407:				;   Function to get a character from the tape reader device.
 408:				;
 409: 2795+17	EECE  CD15FA  	GETRDR:	CALL	READER		;get a character from reader, set status and return.
 410: 2812+10	EED1  C301EF  		JP	SETSTAT
 411:				;
 412:				;  Function to perform direct console i/o. If (C) contains (FF)
 413:				; then this is an input request. If (C) contains (FE) then
 414:				; this is a status request. Otherwise we are to output (C).
 415:				;
 416: 2822+4	EED4  79      	DIRCIO:	LD	A,C		;test for (FF).
 417: 2826+4	EED5  3C      		INC	A
 418: 2830+10	EED6  CAE0EE  		JP	Z,DIRC1
 419: 2840+4	EED9  3C      		INC	A		;test for (FE).
 420: 2844+10	EEDA  CA06FA  		JP	Z,CONST
 421: 2854+10	EEDD  C30CFA  		JP	CONOUT		;just output (C).
 422: 2864+17	EEE0  CD06FA  	DIRC1:	CALL	CONST		;this is an input request.
 423: 2881+4	EEE3  B7      		OR	A
 424: 2885+10	EEE4  CA91F9  		JP	Z,GOBACK1	;not ready? Just return (directly).
 425: 2895+17	EEE7  CD09FA  		CALL	CONIN		;yes, get character.
 426: 2912+10	EEEA  C301EF  		JP	SETSTAT		;set status and return.
 427:				;
 428:				;   Function to return the i/o byte.
 429:				;
 430: 2922+13	EEED  3A0300  	GETIOB:	LD	A,(IOBYTE)
 431: 2935+10	EEF0  C301EF  		JP	SETSTAT
 432:				;
 433:				;   Function to set the i/o byte.
 434:				;
 435: 2945+10	EEF3  210300  	SETIOB:	LD	HL,IOBYTE
 436: 2955+7	EEF6  71      		LD	(HL),C
 437: 2962+10	EEF7  C9      		RET
 438:				;
 439:				;   Function to print the character string pointed to by (DE)
 440:				; on the console device. The string ends with a '$'.
 441:				;
 442: 2972+4	EEF8  EB      	PRTSTR:	EX	DE,HL
 443: 2976+4	EEF9  4D      		LD	C,L
 444: 2980+4	EEFA  44      		LD	B,H		;now (BC) points to it.
 445: 2984+10	EEFB  C3D3ED  		JP	PRTMESG
 446:				;
 447:				;   Function to interigate the console device.
 448:				;
 449: 2994+17	EEFE  CD23ED  	GETCSTS:CALL	CKCONSOL
 450:				;
 451:				;   Get here to set the status and return to the cleanup
 452:				; section. Then back to the user.
 453:				;
 454: 3011+13	EF01  3245EF  	SETSTAT:LD	(STATUS),A
 455: 3024+10	EF04  C9      	RTN:	RET
 456:				;
 457:				;   Set the status to 1 (read or write error code).
 458:				;
 459: 3034+7	EF05  3E01    	IOERR1:	LD	A,1
 460: 3041+10	EF07  C301EF  		JP	SETSTAT
 461:				;
 462:     -	EF0A  00      	OUTFLAG:DEFB	0		;output flag (non zero means no output).
 463:     -	EF0B  02      	STARTING: DEFB	2		;starting position for cursor.
 464:     -	EF0C  00      	CURPOS:	DEFB	0		;cursor position (0=start of line).
 465:     -	EF0D  00      	PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
 466:     -	EF0E  00      	CHARBUF:DEFB	0		;single input character buffer.
 467:				;
 468:				;   Stack area for BDOS calls.
 469:				;
 470:     -	EF0F  0000    	USRSTACK: DW	0		;save users stack pointer here.
 471:				;
 472:     -	EF11  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
	              00000000
	              00000000
 473:     -	EF29  00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
	              00000000
	              00000000
 474:     -	EF41          	STKAREA EQU	$		;end of stack area.
 475:				;
 476:     -	EF41  00      	USERNO:	DEFB	0		;current user number.
 477:     -	EF42  00      	ACTIVE:	DEFB	0		;currently active drive.
 478:     -	EF43  0000    	PARAMS:	DW	0		;save (DE) parameters here on entry.
 479:     -	EF45  0000    	STATUS:	DW	0		;status returned from bdos function.
 480:				;
 481:				;   Select error occured, jump to error routine.
 482:				;
 483: 3051+10	EF47  210BEC  	SLCTERR:LD	HL,BADSLCT
 484:				;
 485:				;   Jump to (HL) indirectly.
 486:				;
 487: 3061+7	EF4A  5E      	JUMPHL:	LD	E,(HL)
 488: 3068+6	EF4B  23      		INC	HL
 489: 3074+7	EF4C  56      		LD	D,(HL)		;now (DE) contain the desired address.
 490: 3081+4	EF4D  EB      		EX	DE,HL
 491: 3085+4	EF4E  E9      		JP	(HL)
 492:				;
 493:				;   Block move. (DE) to (HL), (C) bytes total.
 494:				;
 495: 3089+4	EF4F  0C      	DE2HL:	INC	C		;is count down to zero?
 496: 3093+4	EF50  0D      	DE2HL1:	DEC	C
 497: 3097+5+6	EF51  C8      		RET	Z		;yes, we are done.
 498: 3102+7	EF52  1A      		LD	A,(DE)		;no, move one more byte.
 499: 3109+7	EF53  77      		LD	(HL),A
 500: 3116+6	EF54  13      		INC	DE
 501: 3122+6	EF55  23      		INC	HL
 502: 3128+10	EF56  C350EF  		JP	DE2HL1		;and repeat.
 503:				;
 504:				;   Select the desired drive.
 505:				;
 506: 3138+13	EF59  3A42EF  	SELECT:	LD	A,(ACTIVE)	;get active disk.
 507: 3151+4	EF5C  4F      		LD	C,A
 508: 3155+17	EF5D  CD1BFA  		CALL	SELDSK		;select it.
 509: 3172+4	EF60  7C      		LD	A,H		;valid drive?
 510: 3176+4	EF61  B5      		OR	L		;valid drive?
 511: 3180+5+6	EF62  C8      		RET	Z		;return if not.
 512:				;
 513:				;   Here, the BIOS returned the address of the parameter block
 514:				; in (HL). We will extract the necessary pointers and save them.
 515:				;
 516: 3185+7	EF63  5E      		LD	E,(HL)		;yes, get address of translation table into (DE).
 517: 3192+6	EF64  23      		INC	HL
 518: 3198+7	EF65  56      		LD	D,(HL)
 519: 3205+6	EF66  23      		INC	HL
 520: 3211+16	EF67  22B3F9  		LD	(SCRATCH1),HL	;save pointers to scratch areas.
 521: 3227+6	EF6A  23      		INC	HL
 522: 3233+6	EF6B  23      		INC	HL
 523: 3239+16	EF6C  22B5F9  		LD	(SCRATCH2),HL	;ditto.
 524: 3255+6	EF6F  23      		INC	HL
 525: 3261+6	EF70  23      		INC	HL
 526: 3267+16	EF71  22B7F9  		LD	(SCRATCH3),HL	;ditto.
 527: 3283+6	EF74  23      		INC	HL
 528: 3289+6	EF75  23      		INC	HL
 529: 3295+4	EF76  EB      		EX	DE,HL		;now save the translation table address.
 530: 3299+16	EF77  22D0F9  		LD	(XLATE),HL
 531: 3315+10	EF7A  21B9F9  		LD	HL,DIRBUF	;put the next 8 bytes here.
 532: 3325+7	EF7D  0E08    		LD	C,8		;they consist of the directory buffer
 533: 3332+17	EF7F  CD4FEF  		CALL	DE2HL		;pointer, parameter block pointer,
 534: 3349+16	EF82  2ABBF9  		LD	HL,(DISKPB)	;check and allocation vectors.
 535: 3365+4	EF85  EB      		EX	DE,HL
 536: 3369+10	EF86  21C1F9  		LD	HL,SECTORS	;move parameter block into our ram.
 537: 3379+7	EF89  0E0F    		LD	C,15		;it is 15 bytes long.
 538: 3386+17	EF8B  CD4FEF  		CALL	DE2HL
 539: 3403+16	EF8E  2AC6F9  		LD	HL,(DSKSIZE)	;check disk size.
 540: 3419+4	EF91  7C      		LD	A,H		;more than 256 blocks on this?
 541: 3423+10	EF92  21DDF9  		LD	HL,BIGDISK
 542: 3433+10	EF95  36FF    		LD	(HL),0FFH	;set to samll.
 543: 3443+4	EF97  B7      		OR	A
 544: 3447+10	EF98  CA9DEF  		JP	Z,SELECT1
 545: 3457+10	EF9B  3600    		LD	(HL),0		;wrong, set to large.
 546: 3467+7	EF9D  3EFF    	SELECT1:LD	A,0FFH		;clear the zero flag.
 547: 3474+4	EF9F  B7      		OR	A
 548: 3478+10	EFA0  C9      		RET
 549:				;
 550:				;   Routine to home the disk track head and clear pointers.
 551:				;
 552: 3488+17	EFA1  CD18FA  	HOMEDRV:CALL	HOME		;home the head.
 553: 3505+4	EFA4  AF      		XOR	A
 554: 3509+16	EFA5  2AB5F9  		LD	HL,(SCRATCH2)	;set our track pointer also.
 555: 3525+7	EFA8  77      		LD	(HL),A
 556: 3532+6	EFA9  23      		INC	HL
 557: 3538+7	EFAA  77      		LD	(HL),A
 558: 3545+16	EFAB  2AB7F9  		LD	HL,(SCRATCH3)	;and our sector pointer.
 559: 3561+7	EFAE  77      		LD	(HL),A
 560: 3568+6	EFAF  23      		INC	HL
 561: 3574+7	EFB0  77      		LD	(HL),A
 562: 3581+10	EFB1  C9      		RET
 563:				;
 564:				;   Do the actual disk read and check the error return status.
 565:				;
 566: 3591+17	EFB2  CD27FA  	DOREAD:	CALL	READ
 567: 3608+10	EFB5  C3BBEF  		JP	IORET
 568:				;
 569:				;   Do the actual disk write and handle any bios error.
 570:				;
 571: 3618+17	EFB8  CD2AFA  	DOWRITE:CALL	WRITE
 572: 3635+4	EFBB  B7      	IORET:	OR	A
 573: 3639+5+6	EFBC  C8      		RET	Z		;return unless an error occured.
 574: 3644+10	EFBD  2109EC  		LD	HL,BADSCTR	;bad read/write on this sector.
 575: 3654+10	EFC0  C34AEF  		JP	JUMPHL
 576:				;
 577:				;   Routine to select the track and sector that the desired
 578:				; block number falls in.
 579:				;
 580: 3664+16	EFC3  2AEAF9  	TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
 581: 3680+7	EFC6  0E02    		LD	C,2		;in directory and compute sector #.
 582: 3687+17	EFC8  CDEAF0  		CALL	SHIFTR		;sector #=file-position/4.
 583: 3704+16	EFCB  22E5F9  		LD	(BLKNMBR),HL	;save this as the block number of interest.
 584: 3720+16	EFCE  22ECF9  		LD	(CKSUMTBL),HL	;what's it doing here too?
 585:				;
 586:				;   if the sector number has already been set (BLKNMBR), enter
 587:				; at this point.
 588:				;
 589: 3736+10	EFD1  21E5F9  	TRKSEC1:LD	HL,BLKNMBR
 590: 3746+7	EFD4  4E      		LD	C,(HL)		;move sector number into (BC).
 591: 3753+6	EFD5  23      		INC	HL
 592: 3759+7	EFD6  46      		LD	B,(HL)
 593: 3766+16	EFD7  2AB7F9  		LD	HL,(SCRATCH3)	;get current sector number and
 594: 3782+7	EFDA  5E      		LD	E,(HL)		;move this into (DE).
 595: 3789+6	EFDB  23      		INC	HL
 596: 3795+7	EFDC  56      		LD	D,(HL)
 597: 3802+16	EFDD  2AB5F9  		LD	HL,(SCRATCH2)	;get current track number.
 598: 3818+7	EFE0  7E      		LD	A,(HL)		;and this into (HL).
 599: 3825+6	EFE1  23      		INC	HL
 600: 3831+7	EFE2  66      		LD	H,(HL)
 601: 3838+4	EFE3  6F      		LD	L,A
 602: 3842+4	EFE4  79      	TRKSEC2:LD	A,C		;is desired sector before current one?
 603: 3846+4	EFE5  93      		SUB	E
 604: 3850+4	EFE6  78      		LD	A,B
 605: 3854+4	EFE7  9A      		SBC	A,D
 606: 3858+10	EFE8  D2FAEF  		JP	NC,TRKSEC3
 607: 3868+11	EFEB  E5      		PUSH	HL		;yes, decrement sectors by one track.
 608: 3879+16	EFEC  2AC1F9  		LD	HL,(SECTORS)	;get sectors per track.
 609: 3895+4	EFEF  7B      		LD	A,E
 610: 3899+4	EFF0  95      		SUB	L
 611: 3903+4	EFF1  5F      		LD	E,A
 612: 3907+4	EFF2  7A      		LD	A,D
 613: 3911+4	EFF3  9C      		SBC	A,H
 614: 3915+4	EFF4  57      		LD	D,A		;now we have backed up one full track.
 615: 3919+10	EFF5  E1      		POP	HL
 616: 3929+6	EFF6  2B      		DEC	HL		;adjust track counter.
 617: 3935+10	EFF7  C3E4EF  		JP	TRKSEC2
 618: 3945+11	EFFA  E5      	TRKSEC3:PUSH	HL		;desired sector is after current one.
 619: 3956+16	EFFB  2AC1F9  		LD	HL,(SECTORS)	;get sectors per track.
 620: 3972+11	EFFE  19      		ADD	HL,DE		;bump sector pointer to next track.
 621: 3983+10	EFFF  DA0FF0  		JP	C,TRKSEC4
 622: 3993+4	F002  79      		LD	A,C		;is desired sector now before current one?
 623: 3997+4	F003  95      		SUB	L
 624: 4001+4	F004  78      		LD	A,B
 625: 4005+4	F005  9C      		SBC	A,H
 626: 4009+10	F006  DA0FF0  		JP	C,TRKSEC4
 627: 4019+4	F009  EB      		EX	DE,HL		;not yes, increment track counter
 628: 4023+10	F00A  E1      		POP	HL		;and continue until it is.
 629: 4033+6	F00B  23      		INC	HL
 630: 4039+10	F00C  C3FAEF  		JP	TRKSEC3
 631:				;
 632:				;   here we have determined the track number that contains the
 633:				; desired sector.
 634:				;
 635: 4049+10	F00F  E1      	TRKSEC4:POP	HL		;get track number (HL).
 636: 4059+11	F010  C5      		PUSH	BC
 637: 4070+11	F011  D5      		PUSH	DE
 638: 4081+11	F012  E5      		PUSH	HL
 639: 4092+4	F013  EB      		EX	DE,HL
 640: 4096+16	F014  2ACEF9  		LD	HL,(OFFSET)	;adjust for first track offset.
 641: 4112+11	F017  19      		ADD	HL,DE
 642: 4123+4	F018  44      		LD	B,H
 643: 4127+4	F019  4D      		LD	C,L
 644: 4131+17	F01A  CD1EFA  		CALL	SETTRK		;select this track.
 645: 4148+10	F01D  D1      		POP	DE		;reset current track pointer.
 646: 4158+16	F01E  2AB5F9  		LD	HL,(SCRATCH2)
 647: 4174+7	F021  73      		LD	(HL),E
 648: 4181+6	F022  23      		INC	HL
 649: 4187+7	F023  72      		LD	(HL),D
 650: 4194+10	F024  D1      		POP	DE
 651: 4204+16	F025  2AB7F9  		LD	HL,(SCRATCH3)	;reset the first sector on this track.
 652: 4220+7	F028  73      		LD	(HL),E
 653: 4227+6	F029  23      		INC	HL
 654: 4233+7	F02A  72      		LD	(HL),D
 655: 4240+10	F02B  C1      		POP	BC
 656: 4250+4	F02C  79      		LD	A,C		;now subtract the desired one.
 657: 4254+4	F02D  93      		SUB	E		;to make it relative (1-# sectors/track).
 658: 4258+4	F02E  4F      		LD	C,A
 659: 4262+4	F02F  78      		LD	A,B
 660: 4266+4	F030  9A      		SBC	A,D
 661: 4270+4	F031  47      		LD	B,A
 662: 4274+16	F032  2AD0F9  		LD	HL,(XLATE)	;translate this sector according to this table.
 663: 4290+4	F035  EB      		EX	DE,HL
 664: 4294+17	F036  CD30FA  		CALL	SECTRN		;let the bios translate it.
 665: 4311+4	F039  4D      		LD	C,L
 666: 4315+4	F03A  44      		LD	B,H
 667: 4319+10	F03B  C321FA  		JP	SETSEC		;and select it.
 668:				;
 669:				;   Compute block number from record number (SAVNREC) and
 670:				; extent number (SAVEXT).
 671:				;
 672: 4329+10	F03E  21C3F9  	GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
 673: 4339+7	F041  4E      		LD	C,(HL)		;note that this is base 2 log of ratio.
 674: 4346+13	F042  3AE3F9  		LD	A,(SAVNREC)	;get record number.
 675: 4359+4	F045  B7      	GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
 676: 4363+4	F046  1F      		RRA
 677: 4367+4	F047  0D      		DEC	C
 678: 4371+10	F048  C245F0  		JP	NZ,GETBLK1
 679: 4381+4	F04B  47      		LD	B,A		;save result in (B).
 680: 4385+7	F04C  3E08    		LD	A,8
 681: 4392+7	F04E  96      		SUB	(HL)
 682: 4399+4	F04F  4F      		LD	C,A		;compute (C)=8-BLKSHFT.
 683: 4403+13	F050  3AE2F9  		LD	A,(SAVEXT)
 684: 4416+4	F053  0D      	GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
 685: 4420+10	F054  CA5CF0  		JP	Z,GETBLK3
 686: 4430+4	F057  B7      		OR	A
 687: 4434+4	F058  17      		RLA
 688: 4438+10	F059  C353F0  		JP	GETBLK2
 689: 4448+4	F05C  80      	GETBLK3:ADD	A,B
 690: 4452+10	F05D  C9      		RET
 691:				;
 692:				;   Routine to extract the (BC) block byte from the fcb pointed
 693:				; to by (PARAMS). If this is a big-disk, then these are 16 bit
 694:				; block numbers, else they are 8 bit numbers.
 695:				; Number is returned in (HL).
 696:				;
 697: 4462+16	F05E  2A43EF  	EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
 698: 4478+10	F061  111000  		LD	DE,16		;block numbers start 16 bytes into fcb.
 699: 4488+11	F064  19      		ADD	HL,DE
 700: 4499+11	F065  09      		ADD	HL,BC
 701: 4510+13	F066  3ADDF9  		LD	A,(BIGDISK)	;are we using a big-disk?
 702: 4523+4	F069  B7      		OR	A
 703: 4527+10	F06A  CA71F0  		JP	Z,EXTBLK1
 704: 4537+7	F06D  6E      		LD	L,(HL)		;no, extract an 8 bit number from the fcb.
 705: 4544+7	F06E  2600    		LD	H,0
 706: 4551+10	F070  C9      		RET
 707: 4561+11	F071  09      	EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
 708: 4572+7	F072  5E      		LD	E,(HL)
 709: 4579+6	F073  23      		INC	HL
 710: 4585+7	F074  56      		LD	D,(HL)
 711: 4592+4	F075  EB      		EX	DE,HL		;return in (HL).
 712: 4596+10	F076  C9      		RET
 713:				;
 714:				;   Compute block number.
 715:				;
 716: 4606+17	F077  CD3EF0  	COMBLK:	CALL	GETBLOCK
 717: 4623+4	F07A  4F      		LD	C,A
 718: 4627+7	F07B  0600    		LD	B,0
 719: 4634+17	F07D  CD5EF0  		CALL	EXTBLK
 720: 4651+16	F080  22E5F9  		LD	(BLKNMBR),HL
 721: 4667+10	F083  C9      		RET
 722:				;
 723:				;   Check for a zero block number (unused).
 724:				;
 725: 4677+16	F084  2AE5F9  	CHKBLK:	LD	HL,(BLKNMBR)
 726: 4693+4	F087  7D      		LD	A,L		;is it zero?
 727: 4697+4	F088  B4      		OR	H
 728: 4701+10	F089  C9      		RET
 729:				;
 730:				;   Adjust physical block (BLKNMBR) and convert to logical
 731:				; sector (LOGSECT). This is the starting sector of this block.
 732:				; The actual sector of interest is then added to this and the
 733:				; resulting sector number is stored back in (BLKNMBR). This
 734:				; will still have to be adjusted for the track number.
 735:				;
 736: 4711+13	F08A  3AC3F9  	LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
 737: 4724+16	F08D  2AE5F9  		LD	HL,(BLKNMBR)	;get physical sector desired.
 738: 4740+11	F090  29      	LOGICL1:ADD	HL,HL		;compute logical sector number.
 739: 4751+4	F091  3D      		DEC	A		;note logical sectors are 128 bytes long.
 740: 4755+10	F092  C290F0  		JP	NZ,LOGICL1
 741: 4765+16	F095  22E7F9  		LD	(LOGSECT),HL	;save logical sector.
 742: 4781+13	F098  3AC4F9  		LD	A,(BLKMASK)	;get block mask.
 743: 4794+4	F09B  4F      		LD	C,A
 744: 4798+13	F09C  3AE3F9  		LD	A,(SAVNREC)	;get next sector to access.
 745: 4811+4	F09F  A1      		AND	C		;extract the relative position within physical block.
 746: 4815+4	F0A0  B5      		OR	L		;and add it too logical sector.
 747: 4819+4	F0A1  6F      		LD	L,A
 748: 4823+16	F0A2  22E5F9  		LD	(BLKNMBR),HL	;and store.
 749: 4839+10	F0A5  C9      		RET
 750:				;
 751:				;   Set (HL) to point to extent byte in fcb.
 752:				;
 753: 4849+16	F0A6  2A43EF  	SETEXT:	LD	HL,(PARAMS)
 754: 4865+10	F0A9  110C00  		LD	DE,12		;it is the twelth byte.
 755: 4875+11	F0AC  19      		ADD	HL,DE
 756: 4886+10	F0AD  C9      		RET
 757:				;
 758:				;   Set (HL) to point to record count byte in fcb and (DE) to
 759:				; next record number byte.
 760:				;
 761: 4896+16	F0AE  2A43EF  	SETHLDE:LD	HL,(PARAMS)
 762: 4912+10	F0B1  110F00  		LD	DE,15		;record count byte (#15).
 763: 4922+11	F0B4  19      		ADD	HL,DE
 764: 4933+4	F0B5  EB      		EX	DE,HL
 765: 4937+10	F0B6  211100  		LD	HL,17		;next record number (#32).
 766: 4947+11	F0B9  19      		ADD	HL,DE
 767: 4958+10	F0BA  C9      		RET
 768:				;
 769:				;   Save current file data from fcb.
 770:				;
 771: 4968+17	F0BB  CDAEF0  	STRDATA:CALL	SETHLDE
 772: 4985+7	F0BE  7E      		LD	A,(HL)		;get and store record count byte.
 773: 4992+13	F0BF  32E3F9  		LD	(SAVNREC),A
 774: 5005+4	F0C2  EB      		EX	DE,HL
 775: 5009+7	F0C3  7E      		LD	A,(HL)		;get and store next record number byte.
 776: 5016+13	F0C4  32E1F9  		LD	(SAVNXT),A
 777: 5029+17	F0C7  CDA6F0  		CALL	SETEXT		;point to extent byte.
 778: 5046+13	F0CA  3AC5F9  		LD	A,(EXTMASK)	;get extent mask.
 779: 5059+7	F0CD  A6      		AND	(HL)
 780: 5066+13	F0CE  32E2F9  		LD	(SAVEXT),A	;and save extent here.
 781: 5079+10	F0D1  C9      		RET
 782:				;
 783:				;   Set the next record to access. If (MODE) is set to 2, then
 784:				; the last record byte (SAVNREC) has the correct number to access.
 785:				; For sequential access, (MODE) will be equal to 1.
 786:				;
 787: 5089+17	F0D2  CDAEF0  	SETNREC:CALL	SETHLDE
 788: 5106+13	F0D5  3AD5F9  		LD	A,(MODE)	;get sequential flag (=1).
 789: 5119+7	F0D8  FE02    		CP	2		;a 2 indicates that no adder is needed.
 790: 5126+10	F0DA  C2DEF0  		JP	NZ,STNREC1
 791: 5136+4	F0DD  AF      		XOR	A		;clear adder (random access?).
 792: 5140+4	F0DE  4F      	STNREC1:LD	C,A
 793: 5144+13	F0DF  3AE3F9  		LD	A,(SAVNREC)	;get last record number.
 794: 5157+4	F0E2  81      		ADD	A,C		;increment record count.
 795: 5161+7	F0E3  77      		LD	(HL),A		;and set fcb's next record byte.
 796: 5168+4	F0E4  EB      		EX	DE,HL
 797: 5172+13	F0E5  3AE1F9  		LD	A,(SAVNXT)	;get next record byte from storage.
 798: 5185+7	F0E8  77      		LD	(HL),A		;and put this into fcb as number of records used.
 799: 5192+10	F0E9  C9      		RET
 800:				;
 801:				;   Shift (HL) right (C) bits.
 802:				;
 803: 5202+4	F0EA  0C      	SHIFTR:	INC	C
 804: 5206+4	F0EB  0D      	SHIFTR1:DEC	C
 805: 5210+5+6	F0EC  C8      		RET	Z
 806: 5215+4	F0ED  7C      		LD	A,H
 807: 5219+4	F0EE  B7      		OR	A
 808: 5223+4	F0EF  1F      		RRA
 809: 5227+4	F0F0  67      		LD	H,A
 810: 5231+4	F0F1  7D      		LD	A,L
 811: 5235+4	F0F2  1F      		RRA
 812: 5239+4	F0F3  6F      		LD	L,A
 813: 5243+10	F0F4  C3EBF0  		JP	SHIFTR1
 814:				;
 815:				;   Compute the check-sum for the directory buffer. Return
 816:				; integer sum in (A).
 817:				;
 818: 5253+7	F0F7  0E80    	CHECKSUM: LD	C,128		;length of buffer.
 819: 5260+16	F0F9  2AB9F9  		LD	HL,(DIRBUF)	;get its location.
 820: 5276+4	F0FC  AF      		XOR	A		;clear summation byte.
 821: 5280+7	F0FD  86      	CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
 822: 5287+6	F0FE  23      		INC	HL
 823: 5293+4	F0FF  0D      		DEC	C
 824: 5297+10	F100  C2FDF0  		JP	NZ,CHKSUM1
 825: 5307+10	F103  C9      		RET
 826:				;
 827:				;   Shift (HL) left (C) bits.
 828:				;
 829: 5317+4	F104  0C      	SHIFTL:	INC	C
 830: 5321+4	F105  0D      	SHIFTL1:DEC	C
 831: 5325+5+6	F106  C8      		RET	Z
 832: 5330+11	F107  29      		ADD	HL,HL		;shift left 1 bit.
 833: 5341+10	F108  C305F1  		JP	SHIFTL1
 834:				;
 835:				;   Routine to set a bit in a 16 bit value contained in (BC).
 836:				; The bit set depends on the current drive selection.
 837:				;
 838: 5351+11	F10B  C5      	SETBIT:	PUSH	BC		;save 16 bit word.
 839: 5362+13	F10C  3A42EF  		LD	A,(ACTIVE)	;get active drive.
 840: 5375+4	F10F  4F      		LD	C,A
 841: 5379+10	F110  210100  		LD	HL,1
 842: 5389+17	F113  CD04F1  		CALL	SHIFTL		;shift bit 0 into place.
 843: 5406+10	F116  C1      		POP	BC		;now 'or' this with the original word.
 844: 5416+4	F117  79      		LD	A,C
 845: 5420+4	F118  B5      		OR	L
 846: 5424+4	F119  6F      		LD	L,A		;low byte done, do high byte.
 847: 5428+4	F11A  78      		LD	A,B
 848: 5432+4	F11B  B4      		OR	H
 849: 5436+4	F11C  67      		LD	H,A
 850: 5440+10	F11D  C9      		RET
 851:				;
 852:				;   Extract the write protect status bit for the current drive.
 853:				; The result is returned in (A), bit 0.
 854:				;
 855: 5450+16	F11E  2AADF9  	GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
 856: 5466+13	F121  3A42EF  		LD	A,(ACTIVE)	;which drive is current?
 857: 5479+4	F124  4F      		LD	C,A
 858: 5483+17	F125  CDEAF0  		CALL	SHIFTR		;shift status such that bit 0 is the
 859: 5500+4	F128  7D      		LD	A,L		;one of interest for this drive.
 860: 5504+7	F129  E601    		AND	01H		;and isolate it.
 861: 5511+10	F12B  C9      		RET
 862:				;
 863:				;   Function to write protect the current disk.
 864:				;
 865: 5521+10	F12C  21ADF9  	WRTPRTD:LD	HL,WRTPRT	;point to status word.
 866: 5531+7	F12F  4E      		LD	C,(HL)		;set (BC) equal to the status.
 867: 5538+6	F130  23      		INC	HL
 868: 5544+7	F131  46      		LD	B,(HL)
 869: 5551+17	F132  CD0BF1  		CALL	SETBIT		;and set this bit according to current drive.
 870: 5568+16	F135  22ADF9  		LD	(WRTPRT),HL	;then save.
 871: 5584+16	F138  2AC8F9  		LD	HL,(DIRSIZE)	;now save directory size limit.
 872: 5600+6	F13B  23      		INC	HL		;remember the last one.
 873: 5606+4	F13C  EB      		EX	DE,HL
 874: 5610+16	F13D  2AB3F9  		LD	HL,(SCRATCH1)	;and store it here.
 875: 5626+7	F140  73      		LD	(HL),E		;put low byte.
 876: 5633+6	F141  23      		INC	HL
 877: 5639+7	F142  72      		LD	(HL),D		;then high byte.
 878: 5646+10	F143  C9      		RET
 879:				;
 880:				;   Check for a read only file.
 881:				;
 882: 5656+17	F144  CD5EF1  	CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
 883: 5673+10	F147  110900  	CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
 884: 5683+11	F14A  19      		ADD	HL,DE
 885: 5694+7	F14B  7E      		LD	A,(HL)
 886: 5701+4	F14C  17      		RLA
 887: 5705+5+6	F14D  D0      		RET	NC		;return if ok.
 888: 5710+10	F14E  210FEC  		LD	HL,ROFILE	;else, print error message and terminate.
 889: 5720+10	F151  C34AEF  		JP	JUMPHL
 890:				;
 891:				;   Check the write protect status of the active disk.
 892:				;
 893: 5730+17	F154  CD1EF1  	CHKWPRT:CALL	GETWPRT
 894: 5747+5+6	F157  C8      		RET	Z		;return if ok.
 895: 5752+10	F158  210DEC  		LD	HL,RODISK	;else print message and terminate.
 896: 5762+10	F15B  C34AEF  		JP	JUMPHL
 897:				;
 898:				;   Routine to set (HL) pointing to the proper entry in the
 899:				; directory buffer.
 900:				;
 901: 5772+16	F15E  2AB9F9  	FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
 902: 5788+13	F161  3AE9F9  		LD	A,(FCBPOS)	;relative position of file.
 903:				;
 904:				;   Routine to add (A) to (HL).
 905:				;
 906: 5801+4	F164  85      	ADDA2HL:ADD	A,L
 907: 5805+4	F165  6F      		LD	L,A
 908: 5809+5+6	F166  D0      		RET	NC
 909: 5814+4	F167  24      		INC	H		;take care of any carry.
 910: 5818+10	F168  C9      		RET
 911:				;
 912:				;   Routine to get the 's2' byte from the fcb supplied in
 913:				; the initial parameter specification.
 914:				;
 915: 5828+16	F169  2A43EF  	GETS2:	LD	HL,(PARAMS)	;get address of fcb.
 916: 5844+10	F16C  110E00  		LD	DE,14		;relative position of 's2'.
 917: 5854+11	F16F  19      		ADD	HL,DE
 918: 5865+7	F170  7E      		LD	A,(HL)		;extract this byte.
 919: 5872+10	F171  C9      		RET
 920:				;
 921:				;   Clear the 's2' byte in the fcb.
 922:				;
 923: 5882+17	F172  CD69F1  	CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
 924: 5899+10	F175  3600    		LD	(HL),0		;now clear it.
 925: 5909+10	F177  C9      		RET
 926:				;
 927:				;   Set bit 7 in the 's2' byte of the fcb.
 928:				;
 929: 5919+17	F178  CD69F1  	SETS2B7:CALL	GETS2		;get the byte.
 930: 5936+7	F17B  F680    		OR	80H		;and set bit 7.
 931: 5943+7	F17D  77      		LD	(HL),A		;then store.
 932: 5950+10	F17E  C9      		RET
 933:				;
 934:				;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
 935:				; the difference. This checks to see if there are more file
 936:				; names in the directory. We are at (FILEPOS) and there are
 937:				; (SCRATCH1) of them to check.
 938:				;
 939: 5960+16	F17F  2AEAF9  	MOREFLS:LD	HL,(FILEPOS)	;we are here.
 940: 5976+4	F182  EB      		EX	DE,HL
 941: 5980+16	F183  2AB3F9  		LD	HL,(SCRATCH1)	;and don't go past here.
 942: 5996+4	F186  7B      		LD	A,E		;compute difference but don't keep.
 943: 6000+7	F187  96      		SUB	(HL)
 944: 6007+6	F188  23      		INC	HL
 945: 6013+4	F189  7A      		LD	A,D
 946: 6017+7	F18A  9E      		SBC	A,(HL)		;set carry if no more names.
 947: 6024+10	F18B  C9      		RET
 948:				;
 949:				;   Call this routine to prevent (SCRATCH1) from being greater
 950:				; than (FILEPOS).
 951:				;
 952: 6034+17	F18C  CD7FF1  	CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
 953: 6051+5+6	F18F  D8      		RET	C
 954: 6056+6	F190  13      		INC	DE		;yes, reset it to (FILEPOS).
 955: 6062+7	F191  72      		LD	(HL),D
 956: 6069+6	F192  2B      		DEC	HL
 957: 6075+7	F193  73      		LD	(HL),E
 958: 6082+10	F194  C9      		RET
 959:				;
 960:				;   Compute (HL)=(DE)-(HL)
 961:				;
 962: 6092+4	F195  7B      	SUBHL:	LD	A,E		;compute difference.
 963: 6096+4	F196  95      		SUB	L
 964: 6100+4	F197  6F      		LD	L,A		;store low byte.
 965: 6104+4	F198  7A      		LD	A,D
 966: 6108+4	F199  9C      		SBC	A,H
 967: 6112+4	F19A  67      		LD	H,A		;and then high byte.
 968: 6116+10	F19B  C9      		RET
 969:				;
 970:				;   Set the directory checksum byte.
 971:				;
 972: 6126+7	F19C  0EFF    	SETDIR:	LD	C,0FFH
 973:				;
 974:				;   Routine to set or compare the directory checksum byte. If
 975:				; (C)=0ffh, then this will set the checksum byte. Else the byte
 976:				; will be checked. If the check fails (the disk has been changed),
 977:				; then this disk will be write protected.
 978:				;
 979: 6133+16	F19E  2AECF9  	CHECKDIR: LD	HL,(CKSUMTBL)
 980: 6149+4	F1A1  EB      		EX	DE,HL
 981: 6153+16	F1A2  2ACCF9  		LD	HL,(ALLOC1)
 982: 6169+17	F1A5  CD95F1  		CALL	SUBHL
 983: 6186+5+6	F1A8  D0      		RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
 984: 6191+11	F1A9  C5      		PUSH	BC
 985: 6202+17	F1AA  CDF7F0  		CALL	CHECKSUM	;else compute checksum.
 986: 6219+16	F1AD  2ABDF9  		LD	HL,(CHKVECT)	;get address of checksum table.
 987: 6235+4	F1B0  EB      		EX	DE,HL
 988: 6239+16	F1B1  2AECF9  		LD	HL,(CKSUMTBL)
 989: 6255+11	F1B4  19      		ADD	HL,DE		;set (HL) to point to byte for this drive.
 990: 6266+10	F1B5  C1      		POP	BC
 991: 6276+4	F1B6  0C      		INC	C		;set or check ?
 992: 6280+10	F1B7  CAC4F1  		JP	Z,CHKDIR1
 993: 6290+7	F1BA  BE      		CP	(HL)		;check them.
 994: 6297+5+6	F1BB  C8      		RET	Z		;return if they are the same.
 995: 6302+17	F1BC  CD7FF1  		CALL	MOREFLS		;not the same, do we care?
 996: 6319+5+6	F1BF  D0      		RET	NC
 997: 6324+17	F1C0  CD2CF1  		CALL	WRTPRTD		;yes, mark this as write protected.
 998: 6341+10	F1C3  C9      		RET
 999: 6351+7	F1C4  77      	CHKDIR1:LD	(HL),A		;just set the byte.
1000: 6358+10	F1C5  C9      		RET
1001:				;
1002:				;   Do a write to the directory of the current disk.
1003:				;
1004: 6368+17	F1C6  CD9CF1  	DIRWRITE: CALL	SETDIR		;set checksum byte.
1005: 6385+17	F1C9  CDE0F1  		CALL	DIRDMA		;set directory dma address.
1006: 6402+7	F1CC  0E01    		LD	C,1		;tell the bios to actually write.
1007: 6409+17	F1CE  CDB8EF  		CALL	DOWRITE		;then do the write.
1008: 6426+10	F1D1  C3DAF1  		JP	DEFDMA
1009:				;
1010:				;   Read from the directory.
1011:				;
1012: 6436+17	F1D4  CDE0F1  	DIRREAD:CALL	DIRDMA		;set the directory dma address.
1013: 6453+17	F1D7  CDB2EF  		CALL	DOREAD		;and read it.
1014:				;
1015:				;   Routine to set the dma address to the users choice.
1016:				;
1017: 6470+10	F1DA  21B1F9  	DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
1018: 6480+10	F1DD  C3E3F1  		JP	DIRDMA1
1019:				;
1020:				;   Routine to set the dma address for directory work.
1021:				;
1022: 6490+10	F1E0  21B9F9  	DIRDMA:	LD	HL,DIRBUF
1023:				;
1024:				;   Set the dma address. On entry, (HL) points to
1025:				; word containing the desired dma address.
1026:				;
1027: 6500+7	F1E3  4E      	DIRDMA1:LD	C,(HL)
1028: 6507+6	F1E4  23      		INC	HL
1029: 6513+7	F1E5  46      		LD	B,(HL)		;setup (BC) and go to the bios to set it.
1030: 6520+10	F1E6  C324FA  		JP	SETDMA
1031:				;
1032:				;   Move the directory buffer into user's dma space.
1033:				;
1034: 6530+16	F1E9  2AB9F9  	MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
1035: 6546+4	F1EC  EB      		EX	DE,HL
1036: 6550+16	F1ED  2AB1F9  		LD	HL,(USERDMA)	; put it here.
1037: 6566+7	F1F0  0E80    		LD	C,128		;this is its length.
1038: 6573+10	F1F2  C34FEF  		JP	DE2HL		;move it now and return.
1039:				;
1040:				;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
1041:				;
1042: 6583+10	F1F5  21EAF9  	CKFILPOS: LD	HL,FILEPOS
1043: 6593+7	F1F8  7E      		LD	A,(HL)
1044: 6600+6	F1F9  23      		INC	HL
1045: 6606+7	F1FA  BE      		CP	(HL)		;are both bytes the same?
1046: 6613+5+6	F1FB  C0      		RET	NZ
1047: 6618+4	F1FC  3C      		INC	A		;yes, but are they each 0ffh?
1048: 6622+10	F1FD  C9      		RET
1049:				;
1050:				;   Set location (FILEPOS) to 0ffffh.
1051:				;
1052: 6632+10	F1FE  21FFFF  	STFILPOS: LD	HL,0FFFFH
1053: 6642+16	F201  22EAF9  		LD	(FILEPOS),HL
1054: 6658+10	F204  C9      		RET
1055:				;
1056:				;   Move on to the next file position within the current
1057:				; directory buffer. If no more exist, set pointer to 0ffffh
1058:				; and the calling routine will check for this. Enter with (C)
1059:				; equal to 0ffh to cause the checksum byte to be set, else we
1060:				; will check this disk and set write protect if checksums are
1061:				; not the same (applies only if another directory sector must
1062:				; be read).
1063:				;
1064: 6668+16	F205  2AC8F9  	NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
1065: 6684+4	F208  EB      		EX	DE,HL
1066: 6688+16	F209  2AEAF9  		LD	HL,(FILEPOS)	;get current count.
1067: 6704+6	F20C  23      		INC	HL		;go on to the next one.
1068: 6710+16	F20D  22EAF9  		LD	(FILEPOS),HL
1069: 6726+17	F210  CD95F1  		CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
1070: 6743+10	F213  D219F2  		JP	NC,NXENT1	;is there more room left?
1071: 6753+10	F216  C3FEF1  		JP	STFILPOS	;no. Set this flag and return.
1072: 6763+13	F219  3AEAF9  	NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
1073: 6776+7	F21C  E603    		AND	03H		;only look within this sector (only 4 entries fit).
1074: 6783+7	F21E  0605    		LD	B,5		;convert to relative position (32 bytes each).
1075: 6790+4	F220  87      	NXENT2:	ADD	A,A		;note that this is not efficient code.
1076: 6794+4	F221  05      		DEC	B		;5 'ADD A's would be better.
1077: 6798+10	F222  C220F2  		JP	NZ,NXENT2
1078: 6808+13	F225  32E9F9  		LD	(FCBPOS),A	;save it as position of fcb.
1079: 6821+4	F228  B7      		OR	A
1080: 6825+5+6	F229  C0      		RET	NZ		;return if we are within buffer.
1081: 6830+11	F22A  C5      		PUSH	BC
1082: 6841+17	F22B  CDC3EF  		CALL	TRKSEC		;we need the next directory sector.
1083: 6858+17	F22E  CDD4F1  		CALL	DIRREAD
1084: 6875+10	F231  C1      		POP	BC
1085: 6885+10	F232  C39EF1  		JP	CHECKDIR
1086:				;
1087:				;   Routine to to get a bit from the disk space allocation
1088:				; map. It is returned in (A), bit position 0. On entry to here,
1089:				; set (BC) to the block number on the disk to check.
1090:				; On return, (D) will contain the original bit position for
1091:				; this block number and (HL) will point to the address for it.
1092:				;
1093: 6895+4	F235  79      	CKBITMAP: LD	A,C		;determine bit number of interest.
1094: 6899+7	F236  E607    		AND	07H		;compute (D)=(E)=(C and 7)+1.
1095: 6906+4	F238  3C      		INC	A
1096: 6910+4	F239  5F      		LD	E,A		;save particular bit number.
1097: 6914+4	F23A  57      		LD	D,A
1098:				;
1099:				;   compute (BC)=(BC)/8.
1100:				;
1101: 6918+4	F23B  79      		LD	A,C
1102: 6922+4	F23C  0F      		RRCA			;now shift right 3 bits.
1103: 6926+4	F23D  0F      		RRCA
1104: 6930+4	F23E  0F      		RRCA
1105: 6934+7	F23F  E61F    		AND	1FH		;and clear bits 7,6,5.
1106: 6941+4	F241  4F      		LD	C,A
1107: 6945+4	F242  78      		LD	A,B
1108: 6949+4	F243  87      		ADD	A,A		;now shift (B) into bits 7,6,5.
1109: 6953+4	F244  87      		ADD	A,A
1110: 6957+4	F245  87      		ADD	A,A
1111: 6961+4	F246  87      		ADD	A,A
1112: 6965+4	F247  87      		ADD	A,A
1113: 6969+4	F248  B1      		OR	C		;and add in (C).
1114: 6973+4	F249  4F      		LD	C,A		;ok, (C) ha been completed.
1115: 6977+4	F24A  78      		LD	A,B		;is there a better way of doing this?
1116: 6981+4	F24B  0F      		RRCA
1117: 6985+4	F24C  0F      		RRCA
1118: 6989+4	F24D  0F      		RRCA
1119: 6993+7	F24E  E61F    		AND	1FH
1120: 7000+4	F250  47      		LD	B,A		;and now (B) is completed.
1121:				;
1122:				;   use this as an offset into the disk space allocation
1123:				; table.
1124:				;
1125: 7004+16	F251  2ABFF9  		LD	HL,(ALOCVECT)
1126: 7020+11	F254  09      		ADD	HL,BC
1127: 7031+7	F255  7E      		LD	A,(HL)		;now get correct byte.
1128: 7038+4	F256  07      	CKBMAP1:RLCA			;get correct bit into position 0.
1129: 7042+4	F257  1D      		DEC	E
1130: 7046+10	F258  C256F2  		JP	NZ,CKBMAP1
1131: 7056+10	F25B  C9      		RET
1132:				;
1133:				;   Set or clear the bit map such that block number (BC) will be marked
1134:				; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
1135:				; 1 then it will be set (don't use anyother values).
1136:				;
1137: 7066+11	F25C  D5      	STBITMAP: PUSH	DE
1138: 7077+17	F25D  CD35F2  		CALL	CKBITMAP	;get the byte of interest.
1139: 7094+7	F260  E6FE    		AND	0FEH		;clear the affected bit.
1140: 7101+10	F262  C1      		POP	BC
1141: 7111+4	F263  B1      		OR	C		;and now set it acording to (C).
1142:				;
1143:				;  entry to restore the original bit position and then store
1144:				; in table. (A) contains the value, (D) contains the bit
1145:				; position (1-8), and (HL) points to the address within the
1146:				; space allocation table for this byte.
1147:				;
1148: 7115+4	F264  0F      	STBMAP1:RRCA			;restore original bit position.
1149: 7119+4	F265  15      		DEC	D
1150: 7123+10	F266  C264F2  		JP	NZ,STBMAP1
1151: 7133+7	F269  77      		LD	(HL),A		;and stor byte in table.
1152: 7140+10	F26A  C9      		RET
1153:				;
1154:				;   Set/clear space used bits in allocation map for this file.
1155:				; On entry, (C)=1 to set the map and (C)=0 to clear it.
1156:				;
1157: 7150+17	F26B  CD5EF1  	SETFILE:CALL	FCB2HL		;get address of fcb
1158: 7167+10	F26E  111000  		LD	DE,16
1159: 7177+11	F271  19      		ADD	HL,DE		;get to block number bytes.
1160: 7188+11	F272  C5      		PUSH	BC
1161: 7199+7	F273  0E11    		LD	C,17		;check all 17 bytes (max) of table.
1162: 7206+10	F275  D1      	SETFL1:	POP	DE
1163: 7216+4	F276  0D      		DEC	C		;done all bytes yet?
1164: 7220+5+6	F277  C8      		RET	Z
1165: 7225+11	F278  D5      		PUSH	DE
1166: 7236+13	F279  3ADDF9  		LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
1167: 7249+4	F27C  B7      		OR	A
1168: 7253+10	F27D  CA88F2  		JP	Z,SETFL2
1169: 7263+11	F280  C5      		PUSH	BC		;only 8 bit numbers. set (BC) to this one.
1170: 7274+11	F281  E5      		PUSH	HL
1171: 7285+7	F282  4E      		LD	C,(HL)		;get low byte from table, always
1172: 7292+7	F283  0600    		LD	B,0		;set high byte to zero.
1173: 7299+10	F285  C38EF2  		JP	SETFL3
1174: 7309+4	F288  0D      	SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
1175: 7313+11	F289  C5      		PUSH	BC
1176: 7324+7	F28A  4E      		LD	C,(HL)		;now get both the low and high bytes.
1177: 7331+6	F28B  23      		INC	HL
1178: 7337+7	F28C  46      		LD	B,(HL)
1179: 7344+11	F28D  E5      		PUSH	HL
1180: 7355+4	F28E  79      	SETFL3:	LD	A,C		;block used?
1181: 7359+4	F28F  B0      		OR	B
1182: 7363+10	F290  CA9DF2  		JP	Z,SETFL4
1183: 7373+16	F293  2AC6F9  		LD	HL,(DSKSIZE)	;is this block number within the
1184: 7389+4	F296  7D      		LD	A,L		;space on the disk?
1185: 7393+4	F297  91      		SUB	C
1186: 7397+4	F298  7C      		LD	A,H
1187: 7401+4	F299  98      		SBC	A,B
1188: 7405+10+7	F29A  D45CF2  		CALL	NC,STBITMAP	;yes, set the proper bit.
1189: 7415+10	F29D  E1      	SETFL4:	POP	HL		;point to next block number in fcb.
1190: 7425+6	F29E  23      		INC	HL
1191: 7431+10	F29F  C1      		POP	BC
1192: 7441+10	F2A0  C375F2  		JP	SETFL1
1193:				;
1194:				;   Construct the space used allocation bit map for the active
1195:				; drive. If a file name starts with '$' and it is under the
1196:				; current user number, then (STATUS) is set to minus 1. Otherwise
1197:				; it is not set at all.
1198:				;
1199: 7451+16	F2A3  2AC6F9  	BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
1200: 7467+7	F2A6  0E03    		LD	C,3
1201: 7474+17	F2A8  CDEAF0  		CALL	SHIFTR		;(HL)=(HL)/8.
1202: 7491+6	F2AB  23      		INC	HL		;at lease 1 byte.
1203: 7497+4	F2AC  44      		LD	B,H
1204: 7501+4	F2AD  4D      		LD	C,L		;set (BC) to the allocation table length.
1205:				;
1206:				;   Initialize the bitmap for this drive. Right now, the first
1207:				; two bytes are specified by the disk parameter block. However
1208:				; a patch could be entered here if it were necessary to setup
1209:				; this table in a special mannor. For example, the bios could
1210:				; determine locations of 'bad blocks' and set them as already
1211:				; 'used' in the map.
1212:				;
1213: 7505+16	F2AE  2ABFF9  		LD	HL,(ALOCVECT)	;now zero out the table now.
1214: 7521+10	F2B1  3600    	BITMAP1:LD	(HL),0
1215: 7531+6	F2B3  23      		INC	HL
1216: 7537+6	F2B4  0B      		DEC	BC
1217: 7543+4	F2B5  78      		LD	A,B
1218: 7547+4	F2B6  B1      		OR	C
1219: 7551+10	F2B7  C2B1F2  		JP	NZ,BITMAP1
1220: 7561+16	F2BA  2ACAF9  		LD	HL,(ALLOC0)	;get initial space used by directory.
1221: 7577+4	F2BD  EB      		EX	DE,HL
1222: 7581+16	F2BE  2ABFF9  		LD	HL,(ALOCVECT)	;and put this into map.
1223: 7597+7	F2C1  73      		LD	(HL),E
1224: 7604+6	F2C2  23      		INC	HL
1225: 7610+7	F2C3  72      		LD	(HL),D
1226:				;
1227:				;   End of initialization portion.
1228:				;
1229: 7617+17	F2C4  CDA1EF  		CALL	HOMEDRV		;now home the drive.
1230: 7634+16	F2C7  2AB3F9  		LD	HL,(SCRATCH1)
1231: 7650+10	F2CA  3603    		LD	(HL),3		;force next directory request to read
1232: 7660+6	F2CC  23      		INC	HL		;in a sector.
1233: 7666+10	F2CD  3600    		LD	(HL),0
1234: 7676+17	F2CF  CDFEF1  		CALL	STFILPOS	;clear initial file position also.
1235: 7693+7	F2D2  0EFF    	BITMAP2:LD	C,0FFH		;read next file name in directory
1236: 7700+17	F2D4  CD05F2  		CALL	NXENTRY		;and set checksum byte.
1237: 7717+17	F2D7  CDF5F1  		CALL	CKFILPOS	;is there another file?
1238: 7734+5+6	F2DA  C8      		RET	Z
1239: 7739+17	F2DB  CD5EF1  		CALL	FCB2HL		;yes, get its address.
1240: 7756+7	F2DE  3EE5    		LD	A,0E5H
1241: 7763+7	F2E0  BE      		CP	(HL)		;empty file entry?
1242: 7770+10	F2E1  CAD2F2  		JP	Z,BITMAP2
1243: 7780+13	F2E4  3A41EF  		LD	A,(USERNO)	;no, correct user number?
1244: 7793+7	F2E7  BE      		CP	(HL)
1245: 7800+10	F2E8  C2F6F2  		JP	NZ,BITMAP3
1246: 7810+6	F2EB  23      		INC	HL
1247: 7816+7	F2EC  7E      		LD	A,(HL)		;yes, does name start with a '$'?
1248: 7823+7	F2ED  D624    		SUB	'$'
1249: 7830+10	F2EF  C2F6F2  		JP	NZ,BITMAP3
1250: 7840+4	F2F2  3D      		DEC	A		;yes, set atatus to minus one.
1251: 7844+13	F2F3  3245EF  		LD	(STATUS),A
1252: 7857+7	F2F6  0E01    	BITMAP3:LD	C,1		;now set this file's space as used in bit map.
1253: 7864+17	F2F8  CD6BF2  		CALL	SETFILE
1254: 7881+17	F2FB  CD8CF1  		CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
1255: 7898+10	F2FE  C3D2F2  		JP	BITMAP2
1256:				;
1257:				;   Set the status (STATUS) and return.
1258:				;
1259: 7908+13	F301  3AD4F9  	STSTATUS: LD	A,(FNDSTAT)
1260: 7921+10	F304  C301EF  		JP	SETSTAT
1261:				;
1262:				;   Check extents in (A) and (C). Set the zero flag if they
1263:				; are the same. The number of 16k chunks of disk space that
1264:				; the directory extent covers is expressad is (EXTMASK+1).
1265:				; No registers are modified.
1266:				;
1267: 7931+11	F307  C5      	SAMEXT:	PUSH	BC
1268: 7942+11	F308  F5      		PUSH	AF
1269: 7953+13	F309  3AC5F9  		LD	A,(EXTMASK)	;get extent mask and use it to
1270: 7966+4	F30C  2F      		CPL			;to compare both extent numbers.
1271: 7970+4	F30D  47      		LD	B,A		;save resulting mask here.
1272: 7974+4	F30E  79      		LD	A,C		;mask first extent and save in (C).
1273: 7978+4	F30F  A0      		AND	B
1274: 7982+4	F310  4F      		LD	C,A
1275: 7986+10	F311  F1      		POP	AF		;now mask second extent and compare
1276: 7996+4	F312  A0      		AND	B		;with the first one.
1277: 8000+4	F313  91      		SUB	C
1278: 8004+7	F314  E61F    		AND	1FH		;(* only check buts 0-4 *)
1279: 8011+10	F316  C1      		POP	BC		;the zero flag is set if they are the same.
1280: 8021+10	F317  C9      		RET			;restore (BC) and return.
1281:				;
1282:				;   Search for the first occurence of a file name. On entry,
1283:				; register (C) should contain the number of bytes of the fcb
1284:				; that must match.
1285:				;
1286: 8031+7	F318  3EFF    	FINDFST:LD	A,0FFH
1287: 8038+13	F31A  32D4F9  		LD	(FNDSTAT),A
1288: 8051+10	F31D  21D8F9  		LD	HL,COUNTER	;save character count.
1289: 8061+7	F320  71      		LD	(HL),C
1290: 8068+16	F321  2A43EF  		LD	HL,(PARAMS)	;get filename to match.
1291: 8084+16	F324  22D9F9  		LD	(SAVEFCB),HL	;and save.
1292: 8100+17	F327  CDFEF1  		CALL	STFILPOS	;clear initial file position (set to 0ffffh).
1293: 8117+17	F32A  CDA1EF  		CALL	HOMEDRV		;home the drive.
1294:				;
1295:				;   Entry to locate the next occurence of a filename within the
1296:				; directory. The disk is not expected to have been changed. If
1297:				; it was, then it will be write protected.
1298:				;
1299: 8134+7	F32D  0E00    	FINDNXT:LD	C,0		;write protect the disk if changed.
1300: 8141+17	F32F  CD05F2  		CALL	NXENTRY		;get next filename entry in directory.
1301: 8158+17	F332  CDF5F1  		CALL	CKFILPOS	;is file position = 0ffffh?
1302: 8175+10	F335  CA94F3  		JP	Z,FNDNXT6	;yes, exit now then.
1303: 8185+16	F338  2AD9F9  		LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
1304: 8201+4	F33B  EB      		EX	DE,HL
1305: 8205+7	F33C  1A      		LD	A,(DE)
1306: 8212+7	F33D  FEE5    		CP	0E5H		;empty directory entry?
1307: 8219+10	F33F  CA4AF3  		JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
1308: 8229+11	F342  D5      		PUSH	DE
1309: 8240+17	F343  CD7FF1  		CALL	MOREFLS		;more files in directory?
1310: 8257+10	F346  D1      		POP	DE
1311: 8267+10	F347  D294F3  		JP	NC,FNDNXT6	;no more. Exit now.
1312: 8277+17	F34A  CD5EF1  	FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
1313: 8294+13	F34D  3AD8F9  		LD	A,(COUNTER)	;get number of bytes (characters) to check.
1314: 8307+4	F350  4F      		LD	C,A
1315: 8311+7	F351  0600    		LD	B,0		;initialize byte position counter.
1316: 8318+4	F353  79      	FNDNXT2:LD	A,C		;are we done with the compare?
1317: 8322+4	F354  B7      		OR	A
1318: 8326+10	F355  CA83F3  		JP	Z,FNDNXT5
1319: 8336+7	F358  1A      		LD	A,(DE)		;no, check next byte.
1320: 8343+7	F359  FE3F    		CP	'?'		;don't care about this character?
1321: 8350+10	F35B  CA7CF3  		JP	Z,FNDNXT4
1322: 8360+4	F35E  78      		LD	A,B		;get bytes position in fcb.
1323: 8364+7	F35F  FE0D    		CP	13		;don't care about the thirteenth byte either.
1324: 8371+10	F361  CA7CF3  		JP	Z,FNDNXT4
1325: 8381+7	F364  FE0C    		CP	12		;extent byte?
1326: 8388+7	F366  1A      		LD	A,(DE)
1327: 8395+10	F367  CA73F3  		JP	Z,FNDNXT3
1328: 8405+7	F36A  96      		SUB	(HL)		;otherwise compare characters.
1329: 8412+7	F36B  E67F    		AND	7FH
1330: 8419+10	F36D  C22DF3  		JP	NZ,FINDNXT	;not the same, check next entry.
1331: 8429+10	F370  C37CF3  		JP	FNDNXT4		;so far so good, keep checking.
1332: 8439+11	F373  C5      	FNDNXT3:PUSH	BC		;check the extent byte here.
1333: 8450+7	F374  4E      		LD	C,(HL)
1334: 8457+17	F375  CD07F3  		CALL	SAMEXT
1335: 8474+10	F378  C1      		POP	BC
1336: 8484+10	F379  C22DF3  		JP	NZ,FINDNXT	;not the same, look some more.
1337:				;
1338:				;   So far the names compare. Bump pointers to the next byte
1339:				; and continue until all (C) characters have been checked.
1340:				;
1341: 8494+6	F37C  13      	FNDNXT4:INC	DE		;bump pointers.
1342: 8500+6	F37D  23      		INC	HL
1343: 8506+4	F37E  04      		INC	B
1344: 8510+4	F37F  0D      		DEC	C		;adjust character counter.
1345: 8514+10	F380  C353F3  		JP	FNDNXT2
1346: 8524+13	F383  3AEAF9  	FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
1347: 8537+7	F386  E603    		AND	03H
1348: 8544+13	F388  3245EF  		LD	(STATUS),A
1349: 8557+10	F38B  21D4F9  		LD	HL,FNDSTAT
1350: 8567+7	F38E  7E      		LD	A,(HL)
1351: 8574+4	F38F  17      		RLA
1352: 8578+5+6	F390  D0      		RET	NC
1353: 8583+4	F391  AF      		XOR	A
1354: 8587+7	F392  77      		LD	(HL),A
1355: 8594+10	F393  C9      		RET
1356:				;
1357:				;   Filename was not found. Set appropriate status.
1358:				;
1359: 8604+17	F394  CDFEF1  	FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
1360: 8621+7	F397  3EFF    		LD	A,0FFH		;say not located.
1361: 8628+10	F399  C301EF  		JP	SETSTAT
1362:				;
1363:				;   Erase files from the directory. Only the first byte of the
1364:				; fcb will be affected. It is set to (E5).
1365:				;
1366: 8638+17	F39C  CD54F1  	ERAFILE:CALL	CHKWPRT		;is disk write protected?
1367: 8655+7	F39F  0E0C    		LD	C,12		;only compare file names.
1368: 8662+17	F3A1  CD18F3  		CALL	FINDFST		;get first file name.
1369: 8679+17	F3A4  CDF5F1  	ERAFIL1:CALL	CKFILPOS	;any found?
1370: 8696+5+6	F3A7  C8      		RET	Z		;nope, we must be done.
1371: 8701+17	F3A8  CD44F1  		CALL	CHKROFL		;is file read only?
1372: 8718+17	F3AB  CD5EF1  		CALL	FCB2HL		;nope, get address of fcb and
1373: 8735+10	F3AE  36E5    		LD	(HL),0E5H	;set first byte to 'empty'.
1374: 8745+7	F3B0  0E00    		LD	C,0		;clear the space from the bit map.
1375: 8752+17	F3B2  CD6BF2  		CALL	SETFILE
1376: 8769+17	F3B5  CDC6F1  		CALL	DIRWRITE	;now write the directory sector back out.
1377: 8786+17	F3B8  CD2DF3  		CALL	FINDNXT		;find the next file name.
1378: 8803+10	F3BB  C3A4F3  		JP	ERAFIL1		;and repeat process.
1379:				;
1380:				;   Look through the space allocation map (bit map) for the
1381:				; next available block. Start searching at block number (BC-1).
1382:				; The search procedure is to look for an empty block that is
1383:				; before the starting block. If not empty, look at a later
1384:				; block number. In this way, we return the closest empty block
1385:				; on either side of the 'target' block number. This will speed
1386:				; access on random devices. For serial devices, this should be
1387:				; changed to look in the forward direction first and then start
1388:				; at the front and search some more.
1389:				;
1390:				;   On return, (DE)= block number that is empty and (HL) =0
1391:				; if no empry block was found.
1392:				;
1393: 8813+4	F3BE  50      	FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
1394: 8817+4	F3BF  59      		LD	E,C
1395:				;
1396:				;   Look before target block. Registers (BC) are used as the lower
1397:				; pointer and (DE) as the upper pointer.
1398:				;
1399: 8821+4	F3C0  79      	FNDSPA1:LD	A,C		;is block 0 specified?
1400: 8825+4	F3C1  B0      		OR	B
1401: 8829+10	F3C2  CAD1F3  		JP	Z,FNDSPA2
1402: 8839+6	F3C5  0B      		DEC	BC		;nope, check previous block.
1403: 8845+11	F3C6  D5      		PUSH	DE
1404: 8856+11	F3C7  C5      		PUSH	BC
1405: 8867+17	F3C8  CD35F2  		CALL	CKBITMAP
1406: 8884+4	F3CB  1F      		RRA			;is this block empty?
1407: 8888+10	F3CC  D2ECF3  		JP	NC,FNDSPA3	;yes. use this.
1408:				;
1409:				;   Note that the above logic gets the first block that it finds
1410:				; that is empty. Thus a file could be written 'backward' making
1411:				; it very slow to access. This could be changed to look for the
1412:				; first empty block and then continue until the start of this
1413:				; empty space is located and then used that starting block.
1414:				; This should help speed up access to some files especially on
1415:				; a well used disk with lots of fairly small 'holes'.
1416:				;
1417: 8898+10	F3CF  C1      		POP	BC		;nope, check some more.
1418: 8908+10	F3D0  D1      		POP	DE
1419:				;
1420:				;   Now look after target block.
1421:				;
1422: 8918+16	F3D1  2AC6F9  	FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
1423: 8934+4	F3D4  7B      		LD	A,E
1424: 8938+4	F3D5  95      		SUB	L
1425: 8942+4	F3D6  7A      		LD	A,D
1426: 8946+4	F3D7  9C      		SBC	A,H
1427: 8950+10	F3D8  D2F4F3  		JP	NC,FNDSPA4
1428: 8960+6	F3DB  13      		INC	DE		;yes, move on to next one.
1429: 8966+11	F3DC  C5      		PUSH	BC
1430: 8977+11	F3DD  D5      		PUSH	DE
1431: 8988+4	F3DE  42      		LD	B,D
1432: 8992+4	F3DF  4B      		LD	C,E
1433: 8996+17	F3E0  CD35F2  		CALL	CKBITMAP	;check it.
1434: 9013+4	F3E3  1F      		RRA			;empty?
1435: 9017+10	F3E4  D2ECF3  		JP	NC,FNDSPA3
1436: 9027+10	F3E7  D1      		POP	DE		;nope, continue searching.
1437: 9037+10	F3E8  C1      		POP	BC
1438: 9047+10	F3E9  C3C0F3  		JP	FNDSPA1
1439:				;
1440:				;   Empty block found. Set it as used and return with (HL)
1441:				; pointing to it (true?).
1442:				;
1443: 9057+4	F3EC  17      	FNDSPA3:RLA			;reset byte.
1444: 9061+4	F3ED  3C      		INC	A		;and set bit 0.
1445: 9065+17	F3EE  CD64F2  		CALL	STBMAP1		;update bit map.
1446: 9082+10	F3F1  E1      		POP	HL		;set return registers.
1447: 9092+10	F3F2  D1      		POP	DE
1448: 9102+10	F3F3  C9      		RET
1449:				;
1450:				;   Free block was not found. If (BC) is not zero, then we have
1451:				; not checked all of the disk space.
1452:				;
1453: 9112+4	F3F4  79      	FNDSPA4:LD	A,C
1454: 9116+4	F3F5  B0      		OR	B
1455: 9120+10	F3F6  C2C0F3  		JP	NZ,FNDSPA1
1456: 9130+10	F3F9  210000  		LD	HL,0		;set 'not found' status.
1457: 9140+10	F3FC  C9      		RET
1458:				;
1459:				;   Move a complete fcb entry into the directory and write it.
1460:				;
1461: 9150+7	F3FD  0E00    	FCBSET:	LD	C,0
1462: 9157+7	F3FF  1E20    		LD	E,32		;length of each entry.
1463:				;
1464:				;   Move (E) bytes from the fcb pointed to by (PARAMS) into
1465:				; fcb in directory starting at relative byte (C). This updated
1466:				; directory buffer is then written to the disk.
1467:				;
1468: 9164+11	F401  D5      	UPDATE:	PUSH	DE
1469: 9175+7	F402  0600    		LD	B,0		;set (BC) to relative byte position.
1470: 9182+16	F404  2A43EF  		LD	HL,(PARAMS)	;get address of fcb.
1471: 9198+11	F407  09      		ADD	HL,BC		;compute starting byte.
1472: 9209+4	F408  EB      		EX	DE,HL
1473: 9213+17	F409  CD5EF1  		CALL	FCB2HL		;get address of fcb to update in directory.
1474: 9230+10	F40C  C1      		POP	BC		;set (C) to number of bytes to change.
1475: 9240+17	F40D  CD4FEF  		CALL	DE2HL
1476: 9257+17	F410  CDC3EF  	UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
1477: 9274+10	F413  C3C6F1  		JP	DIRWRITE	;then write this sector out.
1478:				;
1479:				;   Routine to change the name of all files on the disk with a
1480:				; specified name. The fcb contains the current name as the
1481:				; first 12 characters and the new name 16 bytes into the fcb.
1482:				;
1483: 9284+17	F416  CD54F1  	CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
1484: 9301+7	F419  0E0C    		LD	C,12		;match first 12 bytes of fcb only.
1485: 9308+17	F41B  CD18F3  		CALL	FINDFST		;get first name.
1486: 9325+16	F41E  2A43EF  		LD	HL,(PARAMS)	;get address of fcb.
1487: 9341+7	F421  7E      		LD	A,(HL)		;get user number.
1488: 9348+10	F422  111000  		LD	DE,16		;move over to desired name.
1489: 9358+11	F425  19      		ADD	HL,DE
1490: 9369+7	F426  77      		LD	(HL),A		;keep same user number.
1491: 9376+17	F427  CDF5F1  	CHGNAM1:CALL	CKFILPOS	;any matching file found?
1492: 9393+5+6	F42A  C8      		RET	Z		;no, we must be done.
1493: 9398+17	F42B  CD44F1  		CALL	CHKROFL		;check for read only file.
1494: 9415+7	F42E  0E10    		LD	C,16		;start 16 bytes into fcb.
1495: 9422+7	F430  1E0C    		LD	E,12		;and update the first 12 bytes of directory.
1496: 9429+17	F432  CD01F4  		CALL	UPDATE
1497: 9446+17	F435  CD2DF3  		CALL	FINDNXT		;get te next file name.
1498: 9463+10	F438  C327F4  		JP	CHGNAM1		;and continue.
1499:				;
1500:				;   Update a files attributes. The procedure is to search for
1501:				; every file with the same name as shown in fcb (ignoring bit 7)
1502:				; and then to update it (which includes bit 7). No other changes
1503:				; are made.
1504:				;
1505: 9473+7	F43B  0E0C    	SAVEATTR: LD	C,12		;match first 12 bytes.
1506: 9480+17	F43D  CD18F3  		CALL	FINDFST		;look for first filename.
1507: 9497+17	F440  CDF5F1  	SAVATR1:CALL	CKFILPOS	;was one found?
1508: 9514+5+6	F443  C8      		RET	Z		;nope, we must be done.
1509: 9519+7	F444  0E00    		LD	C,0		;yes, update the first 12 bytes now.
1510: 9526+7	F446  1E0C    		LD	E,12
1511: 9533+17	F448  CD01F4  		CALL	UPDATE		;update filename and write directory.
1512: 9550+17	F44B  CD2DF3  		CALL	FINDNXT		;and get the next file.
1513: 9567+10	F44E  C340F4  		JP	SAVATR1		;then continue until done.
1514:				;
1515:				;  Open a file (name specified in fcb).
1516:				;
1517: 9577+7	F451  0E0F    	OPENIT:	LD	C,15		;compare the first 15 bytes.
1518: 9584+17	F453  CD18F3  		CALL	FINDFST		;get the first one in directory.
1519: 9601+17	F456  CDF5F1  		CALL	CKFILPOS	;any at all?
1520: 9618+5+6	F459  C8      		RET	Z
1521: 9623+17	F45A  CDA6F0  	OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
1522: 9640+7	F45D  7E      		LD	A,(HL)		;and get it.
1523: 9647+11	F45E  F5      		PUSH	AF		;save it and address.
1524: 9658+11	F45F  E5      		PUSH	HL
1525: 9669+17	F460  CD5EF1  		CALL	FCB2HL		;point to fcb in directory.
1526: 9686+4	F463  EB      		EX	DE,HL
1527: 9690+16	F464  2A43EF  		LD	HL,(PARAMS)	;this is the users copy.
1528: 9706+7	F467  0E20    		LD	C,32		;move it into users space.
1529: 9713+11	F469  D5      		PUSH	DE
1530: 9724+17	F46A  CD4FEF  		CALL	DE2HL
1531: 9741+17	F46D  CD78F1  		CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
1532: 9758+10	F470  D1      		POP	DE		;now get the extent byte from this fcb.
1533: 9768+10	F471  210C00  		LD	HL,12
1534: 9778+11	F474  19      		ADD	HL,DE
1535: 9789+7	F475  4E      		LD	C,(HL)		;into (C).
1536: 9796+10	F476  210F00  		LD	HL,15		;now get the record count byte into (B).
1537: 9806+11	F479  19      		ADD	HL,DE
1538: 9817+7	F47A  46      		LD	B,(HL)
1539: 9824+10	F47B  E1      		POP	HL		;keep the same extent as the user had originally.
1540: 9834+10	F47C  F1      		POP	AF
1541: 9844+7	F47D  77      		LD	(HL),A
1542: 9851+4	F47E  79      		LD	A,C		;is it the same as in the directory fcb?
1543: 9855+7	F47F  BE      		CP	(HL)
1544: 9862+4	F480  78      		LD	A,B		;if yes, then use the same record count.
1545: 9866+10	F481  CA8BF4  		JP	Z,OPENIT2
1546: 9876+7	F484  3E00    		LD	A,0		;if the user specified an extent greater than
1547: 9883+10	F486  DA8BF4  		JP	C,OPENIT2	;the one in the directory, then set record count to 0.
1548: 9893+7	F489  3E80    		LD	A,128		;otherwise set to maximum.
1549: 9900+16	F48B  2A43EF  	OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
1550: 9916+10	F48E  110F00  		LD	DE,15
1551: 9926+11	F491  19      		ADD	HL,DE		;compute relative position.
1552: 9937+7	F492  77      		LD	(HL),A		;and set the record count.
1553: 9944+10	F493  C9      		RET
1554:				;
1555:				;   Move two bytes from (DE) to (HL) if (and only if) (HL)
1556:				; point to a zero value (16 bit).
1557:				;   Return with zero flag set it (DE) was moved. Registers (DE)
1558:				; and (HL) are not changed. However (A) is.
1559:				;
1560: 9954+7	F494  7E      	MOVEWORD: LD	A,(HL)		;check for a zero word.
1561: 9961+6	F495  23      		INC	HL
1562: 9967+7	F496  B6      		OR	(HL)		;both bytes zero?
1563: 9974+6	F497  2B      		DEC	HL
1564: 9980+5+6	F498  C0      		RET	NZ		;nope, just return.
1565: 9985+7	F499  1A      		LD	A,(DE)		;yes, move two bytes from (DE) into
1566: 9992+7	F49A  77      		LD	(HL),A		;this zero space.
1567: 9999+6	F49B  13      		INC	DE
1568:10005+6	F49C  23      		INC	HL
1569:10011+7	F49D  1A      		LD	A,(DE)
1570:10018+7	F49E  77      		LD	(HL),A
1571:10025+6	F49F  1B      		DEC	DE		;don't disturb these registers.
1572:10031+6	F4A0  2B      		DEC	HL
1573:10037+10	F4A1  C9      		RET
1574:				;
1575:				;   Get here to close a file specified by (fcb).
1576:				;
1577:10047+4	F4A2  AF      	CLOSEIT:XOR	A		;clear status and file position bytes.
1578:10051+13	F4A3  3245EF  		LD	(STATUS),A
1579:10064+13	F4A6  32EAF9  		LD	(FILEPOS),A
1580:10077+13	F4A9  32EBF9  		LD	(FILEPOS+1),A
1581:10090+17	F4AC  CD1EF1  		CALL	GETWPRT		;get write protect bit for this drive.
1582:10107+5+6	F4AF  C0      		RET	NZ		;just return if it is set.
1583:10112+17	F4B0  CD69F1  		CALL	GETS2		;else get the 's2' byte.
1584:10129+7	F4B3  E680    		AND	80H		;and look at bit 7 (file unmodified?).
1585:10136+5+6	F4B5  C0      		RET	NZ		;just return if set.
1586:10141+7	F4B6  0E0F    		LD	C,15		;else look up this file in directory.
1587:10148+17	F4B8  CD18F3  		CALL	FINDFST
1588:10165+17	F4BB  CDF5F1  		CALL	CKFILPOS	;was it found?
1589:10182+5+6	F4BE  C8      		RET	Z		;just return if not.
1590:10187+10	F4BF  011000  		LD	BC,16		;set (HL) pointing to records used section.
1591:10197+17	F4C2  CD5EF1  		CALL	FCB2HL
1592:10214+11	F4C5  09      		ADD	HL,BC
1593:10225+4	F4C6  EB      		EX	DE,HL
1594:10229+16	F4C7  2A43EF  		LD	HL,(PARAMS)	;do the same for users specified fcb.
1595:10245+11	F4CA  09      		ADD	HL,BC
1596:10256+7	F4CB  0E10    		LD	C,16		;this many bytes are present in this extent.
1597:10263+13	F4CD  3ADDF9  	CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
1598:10276+4	F4D0  B7      		OR	A
1599:10280+10	F4D1  CAE8F4  		JP	Z,CLOSEIT4
1600:10290+7	F4D4  7E      		LD	A,(HL)		;just 8 bit. Get one from users fcb.
1601:10297+4	F4D5  B7      		OR	A
1602:10301+7	F4D6  1A      		LD	A,(DE)		;now get one from directory fcb.
1603:10308+10	F4D7  C2DBF4  		JP	NZ,CLOSEIT2
1604:10318+7	F4DA  77      		LD	(HL),A		;users byte was zero. Update from directory.
1605:10325+4	F4DB  B7      	CLOSEIT2: OR	A
1606:10329+10	F4DC  C2E1F4  		JP	NZ,CLOSEIT3
1607:10339+7	F4DF  7E      		LD	A,(HL)		;directories byte was zero, update from users fcb.
1608:10346+7	F4E0  12      		LD	(DE),A
1609:10353+7	F4E1  BE      	CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
1610:10360+10	F4E2  C21FF5  		JP	NZ,CLOSEIT7	;then close error if they are not the same.
1611:10370+10	F4E5  C3FDF4  		JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
1612:10380+17	F4E8  CD94F4  	CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
1613:10397+4	F4EB  EB      		EX	DE,HL
1614:10401+17	F4EC  CD94F4  		CALL	MOVEWORD	;update directories fcb if it is zero.
1615:10418+4	F4EF  EB      		EX	DE,HL
1616:10422+7	F4F0  1A      		LD	A,(DE)		;if these two values are no different,
1617:10429+7	F4F1  BE      		CP	(HL)		;then a close error occured.
1618:10436+10	F4F2  C21FF5  		JP	NZ,CLOSEIT7
1619:10446+6	F4F5  13      		INC	DE		;check second byte.
1620:10452+6	F4F6  23      		INC	HL
1621:10458+7	F4F7  1A      		LD	A,(DE)
1622:10465+7	F4F8  BE      		CP	(HL)
1623:10472+10	F4F9  C21FF5  		JP	NZ,CLOSEIT7
1624:10482+4	F4FC  0D      		DEC	C		;remember 16 bit values.
1625:10486+6	F4FD  13      	CLOSEIT5: INC	DE		;bump to next item in table.
1626:10492+6	F4FE  23      		INC	HL
1627:10498+4	F4FF  0D      		DEC	C		;there are 16 entries only.
1628:10502+10	F500  C2CDF4  		JP	NZ,CLOSEIT1	;continue if more to do.
1629:10512+10	F503  01ECFF  		LD	BC,0FFECH	;backup 20 places (extent byte).
1630:10522+11	F506  09      		ADD	HL,BC
1631:10533+4	F507  EB      		EX	DE,HL
1632:10537+11	F508  09      		ADD	HL,BC
1633:10548+7	F509  1A      		LD	A,(DE)
1634:10555+7	F50A  BE      		CP	(HL)		;directory's extent already greater than the
1635:10562+10	F50B  DA17F5  		JP	C,CLOSEIT6	;users extent?
1636:10572+7	F50E  77      		LD	(HL),A		;no, update directory extent.
1637:10579+10	F50F  010300  		LD	BC,3		;and update the record count byte in
1638:10589+11	F512  09      		ADD	HL,BC		;directories fcb.
1639:10600+4	F513  EB      		EX	DE,HL
1640:10604+11	F514  09      		ADD	HL,BC
1641:10615+7	F515  7E      		LD	A,(HL)		;get from user.
1642:10622+7	F516  12      		LD	(DE),A		;and put in directory.
1643:10629+7	F517  3EFF    	CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
1644:10636+13	F519  32D2F9  		LD	(CLOSEFLG),A
1645:10649+10	F51C  C310F4  		JP	UPDATE1		;update the directory now.
1646:10659+10	F51F  2145EF  	CLOSEIT7: LD	HL,STATUS	;set return status and then return.
1647:10669+11	F522  35      		DEC	(HL)
1648:10680+10	F523  C9      		RET
1649:				;
1650:				;   Routine to get the next empty space in the directory. It
1651:				; will then be cleared for use.
1652:				;
1653:10690+17	F524  CD54F1  	GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
1654:10707+16	F527  2A43EF  		LD	HL,(PARAMS)	;save current parameters (fcb).
1655:10723+11	F52A  E5      		PUSH	HL
1656:10734+10	F52B  21ACF9  		LD	HL,EMPTYFCB	;use special one for empty space.
1657:10744+16	F52E  2243EF  		LD	(PARAMS),HL
1658:10760+7	F531  0E01    		LD	C,1		;search for first empty spot in directory.
1659:10767+17	F533  CD18F3  		CALL	FINDFST		;(* only check first byte *)
1660:10784+17	F536  CDF5F1  		CALL	CKFILPOS	;none?
1661:10801+10	F539  E1      		POP	HL
1662:10811+16	F53A  2243EF  		LD	(PARAMS),HL	;restore original fcb address.
1663:10827+5+6	F53D  C8      		RET	Z		;return if no more space.
1664:10832+4	F53E  EB      		EX	DE,HL
1665:10836+10	F53F  210F00  		LD	HL,15		;point to number of records for this file.
1666:10846+11	F542  19      		ADD	HL,DE
1667:10857+7	F543  0E11    		LD	C,17		;and clear all of this space.
1668:10864+4	F545  AF      		XOR	A
1669:10868+7	F546  77      	GETMT1:	LD	(HL),A
1670:10875+6	F547  23      		INC	HL
1671:10881+4	F548  0D      		DEC	C
1672:10885+10	F549  C246F5  		JP	NZ,GETMT1
1673:10895+10	F54C  210D00  		LD	HL,13		;clear the 's1' byte also.
1674:10905+11	F54F  19      		ADD	HL,DE
1675:10916+7	F550  77      		LD	(HL),A
1676:10923+17	F551  CD8CF1  		CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
1677:10940+17	F554  CDFDF3  		CALL	FCBSET		;write out this fcb entry to directory.
1678:10957+10	F557  C378F1  		JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
1679:				;
1680:				;   Routine to close the current extent and open the next one
1681:				; for reading.
1682:				;
1683:10967+4	F55A  AF      	GETNEXT:XOR	A
1684:10971+13	F55B  32D2F9  		LD	(CLOSEFLG),A	;clear close flag.
1685:10984+17	F55E  CDA2F4  		CALL	CLOSEIT		;close this extent.
1686:11001+17	F561  CDF5F1  		CALL	CKFILPOS
1687:11018+5+6	F564  C8      		RET	Z		;not there???
1688:11023+16	F565  2A43EF  		LD	HL,(PARAMS)	;get extent byte.
1689:11039+10	F568  010C00  		LD	BC,12
1690:11049+11	F56B  09      		ADD	HL,BC
1691:11060+7	F56C  7E      		LD	A,(HL)		;and increment it.
1692:11067+4	F56D  3C      		INC	A
1693:11071+7	F56E  E61F    		AND	1FH		;keep within range 0-31.
1694:11078+7	F570  77      		LD	(HL),A
1695:11085+10	F571  CA83F5  		JP	Z,GTNEXT1	;overflow?
1696:11095+4	F574  47      		LD	B,A		;mask extent byte.
1697:11099+13	F575  3AC5F9  		LD	A,(EXTMASK)
1698:11112+4	F578  A0      		AND	B
1699:11116+10	F579  21D2F9  		LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
1700:11126+7	F57C  A6      		AND	(HL)
1701:11133+10	F57D  CA8EF5  		JP	Z,GTNEXT2	;if zero, we must read in next extent.
1702:11143+10	F580  C3ACF5  		JP	GTNEXT3		;else, it is already in memory.
1703:11153+10	F583  010200  	GTNEXT1:LD	BC,2		;Point to the 's2' byte.
1704:11163+11	F586  09      		ADD	HL,BC
1705:11174+11	F587  34      		INC	(HL)		;and bump it.
1706:11185+7	F588  7E      		LD	A,(HL)		;too many extents?
1707:11192+7	F589  E60F    		AND	0FH
1708:11199+10	F58B  CAB6F5  		JP	Z,GTNEXT5	;yes, set error code.
1709:				;
1710:				;   Get here to open the next extent.
1711:				;
1712:11209+7	F58E  0E0F    	GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
1713:11216+17	F590  CD18F3  		CALL	FINDFST		;find the first one.
1714:11233+17	F593  CDF5F1  		CALL	CKFILPOS	;none available?
1715:11250+10	F596  C2ACF5  		JP	NZ,GTNEXT3
1716:11260+13	F599  3AD3F9  		LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
1717:11273+4	F59C  3C      		INC	A		;0ffh means reading (so not possible).
1718:11277+10	F59D  CAB6F5  		JP	Z,GTNEXT5	;or an error.
1719:11287+17	F5A0  CD24F5  		CALL	GETEMPTY	;we are writing, get an empty entry.
1720:11304+17	F5A3  CDF5F1  		CALL	CKFILPOS	;none?
1721:11321+10	F5A6  CAB6F5  		JP	Z,GTNEXT5	;error if true.
1722:11331+10	F5A9  C3AFF5  		JP	GTNEXT4		;else we are almost done.
1723:11341+17	F5AC  CD5AF4  	GTNEXT3:CALL	OPENIT1		;open this extent.
1724:11358+17	F5AF  CDBBF0  	GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
1725:11375+4	F5B2  AF      		XOR	A		;clear status and return.
1726:11379+10	F5B3  C301EF  		JP	SETSTAT
1727:				;
1728:				;   Error in extending the file. Too many extents were needed
1729:				; or not enough space on the disk.
1730:				;
1731:11389+17	F5B6  CD05EF  	GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
1732:11406+10	F5B9  C378F1  		JP	SETS2B7		;so this is not written on a close.
1733:				;
1734:				;   Read a sequential file.
1735:				;
1736:11416+7	F5BC  3E01    	RDSEQ:	LD	A,1		;set sequential access mode.
1737:11423+13	F5BE  32D5F9  		LD	(MODE),A
1738:11436+7	F5C1  3EFF    	RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
1739:11443+13	F5C3  32D3F9  		LD	(RDWRTFLG),A
1740:11456+17	F5C6  CDBBF0  		CALL	STRDATA		;put rec# and ext# into fcb.
1741:11473+13	F5C9  3AE3F9  		LD	A,(SAVNREC)	;get next record to read.
1742:11486+10	F5CC  21E1F9  		LD	HL,SAVNXT	;get number of records in extent.
1743:11496+7	F5CF  BE      		CP	(HL)		;within this extent?
1744:11503+10	F5D0  DAE6F5  		JP	C,RDSEQ2
1745:11513+7	F5D3  FE80    		CP	128		;no. Is this extent fully used?
1746:11520+10	F5D5  C2FBF5  		JP	NZ,RDSEQ3	;no. End-of-file.
1747:11530+17	F5D8  CD5AF5  		CALL	GETNEXT		;yes, open the next one.
1748:11547+4	F5DB  AF      		XOR	A		;reset next record to read.
1749:11551+13	F5DC  32E3F9  		LD	(SAVNREC),A
1750:11564+13	F5DF  3A45EF  		LD	A,(STATUS)	;check on open, successful?
1751:11577+4	F5E2  B7      		OR	A
1752:11581+10	F5E3  C2FBF5  		JP	NZ,RDSEQ3	;no, error.
1753:11591+17	F5E6  CD77F0  	RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
1754:11608+17	F5E9  CD84F0  		CALL	CHKBLK		;check it. Within bounds?
1755:11625+10	F5EC  CAFBF5  		JP	Z,RDSEQ3	;no, error.
1756:11635+17	F5EF  CD8AF0  		CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
1757:11652+17	F5F2  CDD1EF  		CALL	TRKSEC1		;set the track and sector for this block #.
1758:11669+17	F5F5  CDB2EF  		CALL	DOREAD		;and read it.
1759:11686+10	F5F8  C3D2F0  		JP	SETNREC		;and set the next record to be accessed.
1760:				;
1761:				;   Read error occured. Set status and return.
1762:				;
1763:11696+10	F5FB  C305EF  	RDSEQ3:	JP	IOERR1
1764:				;
1765:				;   Write the next sequential record.
1766:				;
1767:11706+7	F5FE  3E01    	WTSEQ:	LD	A,1		;set sequential access mode.
1768:11713+13	F600  32D5F9  		LD	(MODE),A
1769:11726+7	F603  3E00    	WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
1770:11733+13	F605  32D3F9  		LD	(RDWRTFLG),A
1771:11746+17	F608  CD54F1  		CALL	CHKWPRT		;check write protect status.
1772:11763+16	F60B  2A43EF  		LD	HL,(PARAMS)
1773:11779+17	F60E  CD47F1  		CALL	CKROF1		;check for read only file, (HL) already set to fcb.
1774:11796+17	F611  CDBBF0  		CALL	STRDATA		;put updated data into fcb.
1775:11813+13	F614  3AE3F9  		LD	A,(SAVNREC)	;get record number to write.
1776:11826+7	F617  FE80    		CP	128		;within range?
1777:11833+10	F619  D205EF  		JP	NC,IOERR1	;no, error(?).
1778:11843+17	F61C  CD77F0  		CALL	COMBLK		;compute block number.
1779:11860+17	F61F  CD84F0  		CALL	CHKBLK		;check number.
1780:11877+7	F622  0E00    		LD	C,0		;is there one to write to?
1781:11884+10	F624  C26EF6  		JP	NZ,WTSEQ6	;yes, go do it.
1782:11894+17	F627  CD3EF0  		CALL	GETBLOCK	;get next block number within fcb to use.
1783:11911+13	F62A  32D7F9  		LD	(RELBLOCK),A	;and save.
1784:11924+10	F62D  010000  		LD	BC,0		;start looking for space from the start
1785:11934+4	F630  B7      		OR	A		;if none allocated as yet.
1786:11938+10	F631  CA3BF6  		JP	Z,WTSEQ2
1787:11948+4	F634  4F      		LD	C,A		;extract previous block number from fcb
1788:11952+6	F635  0B      		DEC	BC		;so we can be closest to it.
1789:11958+17	F636  CD5EF0  		CALL	EXTBLK
1790:11975+4	F639  44      		LD	B,H
1791:11979+4	F63A  4D      		LD	C,L
1792:11983+17	F63B  CDBEF3  	WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
1793:12000+4	F63E  7D      		LD	A,L		;check for a zero number.
1794:12004+4	F63F  B4      		OR	H
1795:12008+10	F640  C248F6  		JP	NZ,WTSEQ3
1796:12018+7	F643  3E02    		LD	A,2		;no more space?
1797:12025+10	F645  C301EF  		JP	SETSTAT
1798:12035+16	F648  22E5F9  	WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
1799:12051+4	F64B  EB      		EX	DE,HL		;put block number into (DE).
1800:12055+16	F64C  2A43EF  		LD	HL,(PARAMS)	;now we must update the fcb for this
1801:12071+10	F64F  011000  		LD	BC,16		;newly allocated block.
1802:12081+11	F652  09      		ADD	HL,BC
1803:12092+13	F653  3ADDF9  		LD	A,(BIGDISK)	;8 or 16 bit block numbers?
1804:12105+4	F656  B7      		OR	A
1805:12109+13	F657  3AD7F9  		LD	A,(RELBLOCK)	;(* update this entry *)
1806:12122+10	F65A  CA64F6  		JP	Z,WTSEQ4	;zero means 16 bit ones.
1807:12132+17	F65D  CD64F1  		CALL	ADDA2HL		;(HL)=(HL)+(A)
1808:12149+7	F660  73      		LD	(HL),E		;store new block number.
1809:12156+10	F661  C36CF6  		JP	WTSEQ5
1810:12166+4	F664  4F      	WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
1811:12170+7	F665  0600    		LD	B,0
1812:12177+11	F667  09      		ADD	HL,BC
1813:12188+11	F668  09      		ADD	HL,BC
1814:12199+7	F669  73      		LD	(HL),E		;stuff block number (DE) there.
1815:12206+6	F66A  23      		INC	HL
1816:12212+7	F66B  72      		LD	(HL),D
1817:12219+7	F66C  0E02    	WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
1818:12226+13	F66E  3A45EF  	WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
1819:12239+4	F671  B7      		OR	A
1820:12243+5+6	F672  C0      		RET	NZ
1821:12248+11	F673  C5      		PUSH	BC		;yes, save write flag for bios (register C).
1822:12259+17	F674  CD8AF0  		CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
1823:12276+13	F677  3AD5F9  		LD	A,(MODE)	;get access mode flag (1=sequential,
1824:12289+4	F67A  3D      		DEC	A		;0=random, 2=special?).
1825:12293+4	F67B  3D      		DEC	A
1826:12297+10	F67C  C2BBF6  		JP	NZ,WTSEQ9
1827:				;
1828:				;   Special random i/o from function #40. Maybe for M/PM, but the
1829:				; current block, if it has not been written to, will be zeroed
1830:				; out and then written (reason?).
1831:				;
1832:12307+10	F67F  C1      		POP	BC
1833:12317+11	F680  C5      		PUSH	BC
1834:12328+4	F681  79      		LD	A,C		;get write status flag (2=writing unused space).
1835:12332+4	F682  3D      		DEC	A
1836:12336+4	F683  3D      		DEC	A
1837:12340+10	F684  C2BBF6  		JP	NZ,WTSEQ9
1838:12350+11	F687  E5      		PUSH	HL
1839:12361+16	F688  2AB9F9  		LD	HL,(DIRBUF)	;zero out the directory buffer.
1840:12377+4	F68B  57      		LD	D,A		;note that (A) is zero here.
1841:12381+7	F68C  77      	WTSEQ7:	LD	(HL),A
1842:12388+6	F68D  23      		INC	HL
1843:12394+4	F68E  14      		INC	D		;do 128 bytes.
1844:12398+10	F68F  F28CF6  		JP	P,WTSEQ7
1845:12408+17	F692  CDE0F1  		CALL	DIRDMA		;tell the bios the dma address for directory access.
1846:12425+16	F695  2AE7F9  		LD	HL,(LOGSECT)	;get sector that starts current block.
1847:12441+7	F698  0E02    		LD	C,2		;set 'writing to unused space' flag.
1848:12448+16	F69A  22E5F9  	WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
1849:12464+11	F69D  C5      		PUSH	BC
1850:12475+17	F69E  CDD1EF  		CALL	TRKSEC1		;determine its track and sector numbers.
1851:12492+10	F6A1  C1      		POP	BC
1852:12502+17	F6A2  CDB8EF  		CALL	DOWRITE		;now write out 128 bytes of zeros.
1853:12519+16	F6A5  2AE5F9  		LD	HL,(BLKNMBR)	;get sector number.
1854:12535+7	F6A8  0E00    		LD	C,0		;set normal write flag.
1855:12542+13	F6AA  3AC4F9  		LD	A,(BLKMASK)	;determine if we have written the entire
1856:12555+4	F6AD  47      		LD	B,A		;physical block.
1857:12559+4	F6AE  A5      		AND	L
1858:12563+4	F6AF  B8      		CP	B
1859:12567+6	F6B0  23      		INC	HL		;prepare for the next one.
1860:12573+10	F6B1  C29AF6  		JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
1861:12583+10	F6B4  E1      		POP	HL		;reset next sector number.
1862:12593+16	F6B5  22E5F9  		LD	(BLKNMBR),HL
1863:12609+17	F6B8  CDDAF1  		CALL	DEFDMA		;and reset dma address.
1864:				;
1865:				;   Normal disk write. Set the desired track and sector then
1866:				; do the actual write.
1867:				;
1868:12626+17	F6BB  CDD1EF  	WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
1869:12643+10	F6BE  C1      		POP	BC		;get write status flag.
1870:12653+11	F6BF  C5      		PUSH	BC
1871:12664+17	F6C0  CDB8EF  		CALL	DOWRITE		;and write this out.
1872:12681+10	F6C3  C1      		POP	BC
1873:12691+13	F6C4  3AE3F9  		LD	A,(SAVNREC)	;get number of records in file.
1874:12704+10	F6C7  21E1F9  		LD	HL,SAVNXT	;get last record written.
1875:12714+7	F6CA  BE      		CP	(HL)
1876:12721+10	F6CB  DAD2F6  		JP	C,WTSEQ10
1877:12731+7	F6CE  77      		LD	(HL),A		;we have to update record count.
1878:12738+11	F6CF  34      		INC	(HL)
1879:12749+7	F6D0  0E02    		LD	C,2
1880:				;
1881:				;*   This area has been patched to correct disk update problem
1882:				;* when using blocking and de-blocking in the BIOS.
1883:				;
1884:12756+4	F6D2  00      	WTSEQ10:NOP			;was 'dcr c'
1885:12760+4	F6D3  00      		NOP			;was 'dcr c'
1886:12764+10	F6D4  210000  		LD	HL,0		;was 'jnz wtseq99'
1887:				;
1888:				; *   End of patch.
1889:				;
1890:12774+11	F6D7  F5      		PUSH	AF
1891:12785+17	F6D8  CD69F1  		CALL	GETS2		;set 'extent written to' flag.
1892:12802+7	F6DB  E67F    		AND	7FH		;(* clear bit 7 *)
1893:12809+7	F6DD  77      		LD	(HL),A
1894:12816+10	F6DE  F1      		POP	AF		;get record count for this extent.
1895:12826+7	F6DF  FE7F    	WTSEQ99:CP	127		;is it full?
1896:12833+10	F6E1  C200F7  		JP	NZ,WTSEQ12
1897:12843+13	F6E4  3AD5F9  		LD	A,(MODE)	;yes, are we in sequential mode?
1898:12856+7	F6E7  FE01    		CP	1
1899:12863+10	F6E9  C200F7  		JP	NZ,WTSEQ12
1900:12873+17	F6EC  CDD2F0  		CALL	SETNREC		;yes, set next record number.
1901:12890+17	F6EF  CD5AF5  		CALL	GETNEXT		;and get next empty space in directory.
1902:12907+10	F6F2  2145EF  		LD	HL,STATUS	;ok?
1903:12917+7	F6F5  7E      		LD	A,(HL)
1904:12924+4	F6F6  B7      		OR	A
1905:12928+10	F6F7  C2FEF6  		JP	NZ,WTSEQ11
1906:12938+4	F6FA  3D      		DEC	A		;yes, set record count to -1.
1907:12942+13	F6FB  32E3F9  		LD	(SAVNREC),A
1908:12955+10	F6FE  3600    	WTSEQ11:LD	(HL),0		;clear status.
1909:12965+10	F700  C3D2F0  	WTSEQ12:JP	SETNREC		;set next record to access.
1910:				;
1911:				;   For random i/o, set the fcb for the desired record number
1912:				; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
1913:				; used as follows:
1914:				;
1915:				;       fcb+35            fcb+34            fcb+33
1916:				;  |     'r-2'      |      'r-1'      |      'r-0'     |
1917:				;  |7             0 | 7             0 | 7             0|
1918:				;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
1919:				;  |    overflow   | | extra |  extent   |   record #  |
1920:				;  | ______________| |_extent|__number___|_____________|
1921:				;                     also 's2'
1922:				;
1923:				;   On entry, register (C) contains 0ffh if this is a read
1924:				; and thus we can not access unwritten disk space. Otherwise,
1925:				; another extent will be opened (for writing) if required.
1926:				;
1927:12975+4	F703  AF      	POSITION: XOR	A		;set random i/o flag.
1928:12979+13	F704  32D5F9  		LD	(MODE),A
1929:				;
1930:				;   Special entry (function #40). M/PM ?
1931:				;
1932:12992+11	F707  C5      	POSITN1:PUSH	BC		;save read/write flag.
1933:13003+16	F708  2A43EF  		LD	HL,(PARAMS)	;get address of fcb.
1934:13019+4	F70B  EB      		EX	DE,HL
1935:13023+10	F70C  212100  		LD	HL,33		;now get byte 'r0'.
1936:13033+11	F70F  19      		ADD	HL,DE
1937:13044+7	F710  7E      		LD	A,(HL)
1938:13051+7	F711  E67F    		AND	7FH		;keep bits 0-6 for the record number to access.
1939:13058+11	F713  F5      		PUSH	AF
1940:13069+7	F714  7E      		LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
1941:13076+4	F715  17      		RLA
1942:13080+6	F716  23      		INC	HL
1943:13086+7	F717  7E      		LD	A,(HL)
1944:13093+4	F718  17      		RLA
1945:13097+7	F719  E61F    		AND	1FH		;and save this in bits 0-4 of (C).
1946:13104+4	F71B  4F      		LD	C,A		;this is the extent byte.
1947:13108+7	F71C  7E      		LD	A,(HL)		;now get the extra extent byte.
1948:13115+4	F71D  1F      		RRA
1949:13119+4	F71E  1F      		RRA
1950:13123+4	F71F  1F      		RRA
1951:13127+4	F720  1F      		RRA
1952:13131+7	F721  E60F    		AND	0FH
1953:13138+4	F723  47      		LD	B,A		;and save it in (B).
1954:13142+10	F724  F1      		POP	AF		;get record number back to (A).
1955:13152+6	F725  23      		INC	HL		;check overflow byte 'r2'.
1956:13158+7	F726  6E      		LD	L,(HL)
1957:13165+4	F727  2C      		INC	L
1958:13169+4	F728  2D      		DEC	L
1959:13173+7	F729  2E06    		LD	L,6		;prepare for error.
1960:13180+10	F72B  C28BF7  		JP	NZ,POSITN5	;out of disk space error.
1961:13190+10	F72E  212000  		LD	HL,32		;store record number into fcb.
1962:13200+11	F731  19      		ADD	HL,DE
1963:13211+7	F732  77      		LD	(HL),A
1964:13218+10	F733  210C00  		LD	HL,12		;and now check the extent byte.
1965:13228+11	F736  19      		ADD	HL,DE
1966:13239+4	F737  79      		LD	A,C
1967:13243+7	F738  96      		SUB	(HL)		;same extent as before?
1968:13250+10	F739  C247F7  		JP	NZ,POSITN2
1969:13260+10	F73C  210E00  		LD	HL,14		;yes, check extra extent byte 's2' also.
1970:13270+11	F73F  19      		ADD	HL,DE
1971:13281+4	F740  78      		LD	A,B
1972:13285+7	F741  96      		SUB	(HL)
1973:13292+7	F742  E67F    		AND	7FH
1974:13299+10	F744  CA7FF7  		JP	Z,POSITN3	;same, we are almost done then.
1975:				;
1976:				;  Get here when another extent is required.
1977:				;
1978:13309+11	F747  C5      	POSITN2:PUSH	BC
1979:13320+11	F748  D5      		PUSH	DE
1980:13331+17	F749  CDA2F4  		CALL	CLOSEIT		;close current extent.
1981:13348+10	F74C  D1      		POP	DE
1982:13358+10	F74D  C1      		POP	BC
1983:13368+7	F74E  2E03    		LD	L,3		;prepare for error.
1984:13375+13	F750  3A45EF  		LD	A,(STATUS)
1985:13388+4	F753  3C      		INC	A
1986:13392+10	F754  CA84F7  		JP	Z,POSITN4	;close error.
1987:13402+10	F757  210C00  		LD	HL,12		;put desired extent into fcb now.
1988:13412+11	F75A  19      		ADD	HL,DE
1989:13423+7	F75B  71      		LD	(HL),C
1990:13430+10	F75C  210E00  		LD	HL,14		;and store extra extent byte 's2'.
1991:13440+11	F75F  19      		ADD	HL,DE
1992:13451+7	F760  70      		LD	(HL),B
1993:13458+17	F761  CD51F4  		CALL	OPENIT		;try and get this extent.
1994:13475+13	F764  3A45EF  		LD	A,(STATUS)	;was it there?
1995:13488+4	F767  3C      		INC	A
1996:13492+10	F768  C27FF7  		JP	NZ,POSITN3
1997:13502+10	F76B  C1      		POP	BC		;no. can we create a new one (writing?).
1998:13512+11	F76C  C5      		PUSH	BC
1999:13523+7	F76D  2E04    		LD	L,4		;prepare for error.
2000:13530+4	F76F  0C      		INC	C
2001:13534+10	F770  CA84F7  		JP	Z,POSITN4	;nope, reading unwritten space error.
2002:13544+17	F773  CD24F5  		CALL	GETEMPTY	;yes we can, try to find space.
2003:13561+7	F776  2E05    		LD	L,5		;prepare for error.
2004:13568+13	F778  3A45EF  		LD	A,(STATUS)
2005:13581+4	F77B  3C      		INC	A
2006:13585+10	F77C  CA84F7  		JP	Z,POSITN4	;out of space?
2007:				;
2008:				;   Normal return location. Clear error code and return.
2009:				;
2010:13595+10	F77F  C1      	POSITN3:POP	BC		;restore stack.
2011:13605+4	F780  AF      		XOR	A		;and clear error code byte.
2012:13609+10	F781  C301EF  		JP	SETSTAT
2013:				;
2014:				;   Error. Set the 's2' byte to indicate this (why?).
2015:				;
2016:13619+11	F784  E5      	POSITN4:PUSH	HL
2017:13630+17	F785  CD69F1  		CALL	GETS2
2018:13647+10	F788  36C0    		LD	(HL),0C0H
2019:13657+10	F78A  E1      		POP	HL
2020:				;
2021:				;   Return with error code (presently in L).
2022:				;
2023:13667+10	F78B  C1      	POSITN5:POP	BC
2024:13677+4	F78C  7D      		LD	A,L		;get error code.
2025:13681+13	F78D  3245EF  		LD	(STATUS),A
2026:13694+10	F790  C378F1  		JP	SETS2B7
2027:				;
2028:				;   Read a random record.
2029:				;
2030:13704+7	F793  0EFF    	READRAN:LD	C,0FFH		;set 'read' status.
2031:13711+17	F795  CD03F7  		CALL	POSITION	;position the file to proper record.
2032:13728+10+7	F798  CCC1F5  		CALL	Z,RDSEQ1	;and read it as usual (if no errors).
2033:13738+10	F79B  C9      		RET
2034:				;
2035:				;   Write to a random record.
2036:				;
2037:13748+7	F79C  0E00    	WRITERAN: LD	C,0		;set 'writing' flag.
2038:13755+17	F79E  CD03F7  		CALL	POSITION	;position the file to proper record.
2039:13772+10+7	F7A1  CC03F6  		CALL	Z,WTSEQ1	;and write as usual (if no errors).
2040:13782+10	F7A4  C9      		RET
2041:				;
2042:				;   Compute the random record number. Enter with (HL) pointing
2043:				; to a fcb an (DE) contains a relative location of a record
2044:				; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
2045:				; byte, and (A) the 'r2' byte.
2046:				;
2047:				;   On return, the zero flag is set if the record is within
2048:				; bounds. Otherwise, an overflow occured.
2049:				;
2050:13792+4	F7A5  EB      	COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
2051:13796+11	F7A6  19      		ADD	HL,DE		;compute relative position of record #.
2052:13807+7	F7A7  4E      		LD	C,(HL)		;get record number into (BC).
2053:13814+7	F7A8  0600    		LD	B,0
2054:13821+10	F7AA  210C00  		LD	HL,12		;now get extent.
2055:13831+11	F7AD  19      		ADD	HL,DE
2056:13842+7	F7AE  7E      		LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
2057:13849+4	F7AF  0F      		RRCA			;move lower bit into bit 7.
2058:13853+7	F7B0  E680    		AND	80H		;and ignore all other bits.
2059:13860+4	F7B2  81      		ADD	A,C		;add to our record number.
2060:13864+4	F7B3  4F      		LD	C,A
2061:13868+7	F7B4  3E00    		LD	A,0		;take care of any carry.
2062:13875+4	F7B6  88      		ADC	A,B
2063:13879+4	F7B7  47      		LD	B,A
2064:13883+7	F7B8  7E      		LD	A,(HL)		;now get the upper bits of extent into
2065:13890+4	F7B9  0F      		RRCA			;bit positions 0-3.
2066:13894+7	F7BA  E60F    		AND	0FH		;and ignore all others.
2067:13901+4	F7BC  80      		ADD	A,B		;add this in to 'r1' byte.
2068:13905+4	F7BD  47      		LD	B,A
2069:13909+10	F7BE  210E00  		LD	HL,14		;get the 's2' byte (extra extent).
2070:13919+11	F7C1  19      		ADD	HL,DE
2071:13930+7	F7C2  7E      		LD	A,(HL)
2072:13937+4	F7C3  87      		ADD	A,A		;and shift it left 4 bits (bits 4-7).
2073:13941+4	F7C4  87      		ADD	A,A
2074:13945+4	F7C5  87      		ADD	A,A
2075:13949+4	F7C6  87      		ADD	A,A
2076:13953+11	F7C7  F5      		PUSH	AF		;save carry flag (bit 0 of flag byte).
2077:13964+4	F7C8  80      		ADD	A,B		;now add extra extent into 'r1'.
2078:13968+4	F7C9  47      		LD	B,A
2079:13972+11	F7CA  F5      		PUSH	AF		;and save carry (overflow byte 'r2').
2080:13983+10	F7CB  E1      		POP	HL		;bit 0 of (L) is the overflow indicator.
2081:13993+4	F7CC  7D      		LD	A,L
2082:13997+10	F7CD  E1      		POP	HL		;and same for first carry flag.
2083:14007+4	F7CE  B5      		OR	L		;either one of these set?
2084:14011+7	F7CF  E601    		AND	01H		;only check the carry flags.
2085:14018+10	F7D1  C9      		RET
2086:				;
2087:				;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
2088:				; reflect the last record used for a random (or other) file.
2089:				; This reads the directory and looks at all extents computing
2090:				; the largerst record number for each and keeping the maximum
2091:				; value only. Then 'r0', 'r1', and 'r2' will reflect this
2092:				; maximum record number. This is used to compute the space used
2093:				; by a random file.
2094:				;
2095:14028+7	F7D2  0E0C    	RANSIZE:LD	C,12		;look thru directory for first entry with
2096:14035+17	F7D4  CD18F3  		CALL	FINDFST		;this name.
2097:14052+16	F7D7  2A43EF  		LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
2098:14068+10	F7DA  112100  		LD	DE,33
2099:14078+11	F7DD  19      		ADD	HL,DE
2100:14089+11	F7DE  E5      		PUSH	HL
2101:14100+7	F7DF  72      		LD	(HL),D		;note that (D)=0.
2102:14107+6	F7E0  23      		INC	HL
2103:14113+7	F7E1  72      		LD	(HL),D
2104:14120+6	F7E2  23      		INC	HL
2105:14126+7	F7E3  72      		LD	(HL),D
2106:14133+17	F7E4  CDF5F1  	RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
2107:14150+10	F7E7  CA0CF8  		JP	Z,RANSIZ3	;no, we are done.
2108:14160+17	F7EA  CD5EF1  		CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
2109:14177+10	F7ED  110F00  		LD	DE,15		;point to last record in extent.
2110:14187+17	F7F0  CDA5F7  		CALL	COMPRAND	;and compute random parameters.
2111:14204+10	F7F3  E1      		POP	HL
2112:14214+11	F7F4  E5      		PUSH	HL		;now check these values against those
2113:14225+4	F7F5  5F      		LD	E,A		;already in fcb.
2114:14229+4	F7F6  79      		LD	A,C		;the carry flag will be set if those
2115:14233+7	F7F7  96      		SUB	(HL)		;in the fcb represent a larger size than
2116:14240+6	F7F8  23      		INC	HL		;this extent does.
2117:14246+4	F7F9  78      		LD	A,B
2118:14250+7	F7FA  9E      		SBC	A,(HL)
2119:14257+6	F7FB  23      		INC	HL
2120:14263+4	F7FC  7B      		LD	A,E
2121:14267+7	F7FD  9E      		SBC	A,(HL)
2122:14274+10	F7FE  DA06F8  		JP	C,RANSIZ2
2123:14284+7	F801  73      		LD	(HL),E		;we found a larger (in size) extent.
2124:14291+6	F802  2B      		DEC	HL		;stuff these values into fcb.
2125:14297+7	F803  70      		LD	(HL),B
2126:14304+6	F804  2B      		DEC	HL
2127:14310+7	F805  71      		LD	(HL),C
2128:14317+17	F806  CD2DF3  	RANSIZ2:CALL	FINDNXT		;now get the next extent.
2129:14334+10	F809  C3E4F7  		JP	RANSIZ1		;continue til all done.
2130:14344+10	F80C  E1      	RANSIZ3:POP	HL		;we are done, restore the stack and
2131:14354+10	F80D  C9      		RET			;return.
2132:				;
2133:				;   Function to return the random record position of a given
2134:				; file which has been read in sequential mode up to now.
2135:				;
2136:14364+16	F80E  2A43EF  	SETRAN:	LD	HL,(PARAMS)	;point to fcb.
2137:14380+10	F811  112000  		LD	DE,32		;and to last used record.
2138:14390+17	F814  CDA5F7  		CALL	COMPRAND	;compute random position.
2139:14407+10	F817  212100  		LD	HL,33		;now stuff these values into fcb.
2140:14417+11	F81A  19      		ADD	HL,DE
2141:14428+7	F81B  71      		LD	(HL),C		;move 'r0'.
2142:14435+6	F81C  23      		INC	HL
2143:14441+7	F81D  70      		LD	(HL),B		;and 'r1'.
2144:14448+6	F81E  23      		INC	HL
2145:14454+7	F81F  77      		LD	(HL),A		;and lastly 'r2'.
2146:14461+10	F820  C9      		RET
2147:				;
2148:				;   This routine select the drive specified in (ACTIVE) and
2149:				; update the login vector and bitmap table if this drive was
2150:				; not already active.
2151:				;
2152:14471+16	F821  2AAFF9  	LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
2153:14487+13	F824  3A42EF  		LD	A,(ACTIVE)	;get the default drive.
2154:14500+4	F827  4F      		LD	C,A
2155:14504+17	F828  CDEAF0  		CALL	SHIFTR		;position active bit for this drive
2156:14521+11	F82B  E5      		PUSH	HL		;into bit 0.
2157:14532+4	F82C  EB      		EX	DE,HL
2158:14536+17	F82D  CD59EF  		CALL	SELECT		;select this drive.
2159:14553+10	F830  E1      		POP	HL
2160:14563+10+7	F831  CC47EF  		CALL	Z,SLCTERR	;valid drive?
2161:14573+4	F834  7D      		LD	A,L		;is this a newly activated drive?
2162:14577+4	F835  1F      		RRA
2163:14581+5+6	F836  D8      		RET	C
2164:14586+16	F837  2AAFF9  		LD	HL,(LOGIN)	;yes, update the login vector.
2165:14602+4	F83A  4D      		LD	C,L
2166:14606+4	F83B  44      		LD	B,H
2167:14610+17	F83C  CD0BF1  		CALL	SETBIT
2168:14627+16	F83F  22AFF9  		LD	(LOGIN),HL	;and save.
2169:14643+10	F842  C3A3F2  		JP	BITMAP		;now update the bitmap.
2170:				;
2171:				;   Function to set the active disk number.
2172:				;
2173:14653+13	F845  3AD6F9  	SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
2174:14666+10	F848  2142EF  		LD	HL,ACTIVE	;represents a change in drives.
2175:14676+7	F84B  BE      		CP	(HL)
2176:14683+5+6	F84C  C8      		RET	Z
2177:14688+7	F84D  77      		LD	(HL),A		;yes it does, log it in.
2178:14695+10	F84E  C321F8  		JP	LOGINDRV
2179:				;
2180:				;   This is the 'auto disk select' routine. The firsst byte
2181:				; of the fcb is examined for a drive specification. If non
2182:				; zero then the drive will be selected and loged in.
2183:				;
2184:14705+7	F851  3EFF    	AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
2185:14712+13	F853  32DEF9  		LD	(AUTO),A
2186:14725+16	F856  2A43EF  		LD	HL,(PARAMS)	;get drive specified.
2187:14741+7	F859  7E      		LD	A,(HL)
2188:14748+7	F85A  E61F    		AND	1FH		;look at lower 5 bits.
2189:14755+4	F85C  3D      		DEC	A		;adjust for (1=A, 2=B) etc.
2190:14759+13	F85D  32D6F9  		LD	(EPARAM),A	;and save for the select routine.
2191:14772+7	F860  FE1E    		CP	1EH		;check for 'no change' condition.
2192:14779+10	F862  D275F8  		JP	NC,AUTOSL1	;yes, don't change.
2193:14789+13	F865  3A42EF  		LD	A,(ACTIVE)	;we must change, save currently active
2194:14802+13	F868  32DFF9  		LD	(OLDDRV),A	;drive.
2195:14815+7	F86B  7E      		LD	A,(HL)		;and save first byte of fcb also.
2196:14822+13	F86C  32E0F9  		LD	(AUTOFLAG),A	;this must be non-zero.
2197:14835+7	F86F  E6E0    		AND	0E0H		;whats this for (bits 6,7 are used for
2198:14842+7	F871  77      		LD	(HL),A		;something)?
2199:14849+17	F872  CD45F8  		CALL	SETDSK		;select and log in this drive.
2200:14866+13	F875  3A41EF  	AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
2201:14879+16	F878  2A43EF  		LD	HL,(PARAMS)	;(* upper half of first byte *)
2202:14895+7	F87B  B6      		OR	(HL)
2203:14902+7	F87C  77      		LD	(HL),A
2204:14909+10	F87D  C9      		RET			;and return (all done).
2205:				;
2206:				;   Function to return the current cp/m version number.
2207:				;
2208:14919+7	F87E  3E22    	GETVER:	LD	A,022H		;version 2.2
2209:14926+10	F880  C301EF  		JP	SETSTAT
2210:				;
2211:				;   Function to reset the disk system.
2212:				;
2213:14936+10	F883  210000  	RSTDSK:	LD	HL,0		;clear write protect status and log
2214:14946+16	F886  22ADF9  		LD	(WRTPRT),HL	;in vector.
2215:14962+16	F889  22AFF9  		LD	(LOGIN),HL
2216:14978+4	F88C  AF      		XOR	A		;select drive 'A'.
2217:14982+13	F88D  3242EF  		LD	(ACTIVE),A
2218:14995+10	F890  218000  		LD	HL,TBUFF	;setup default dma address.
2219:15005+16	F893  22B1F9  		LD	(USERDMA),HL
2220:15021+17	F896  CDDAF1  		CALL	DEFDMA
2221:15038+10	F899  C321F8  		JP	LOGINDRV	;now log in drive 'A'.
2222:				;
2223:				;   Function to open a specified file.
2224:				;
2225:15048+17	F89C  CD72F1  	OPENFIL:CALL	CLEARS2		;clear 's2' byte.
2226:15065+17	F89F  CD51F8  		CALL	AUTOSEL		;select proper disk.
2227:15082+10	F8A2  C351F4  		JP	OPENIT		;and open the file.
2228:				;
2229:				;   Function to close a specified file.
2230:				;
2231:15092+17	F8A5  CD51F8  	CLOSEFIL: CALL	AUTOSEL		;select proper disk.
2232:15109+10	F8A8  C3A2F4  		JP	CLOSEIT		;and close the file.
2233:				;
2234:				;   Function to return the first occurence of a specified file
2235:				; name. If the first byte of the fcb is '?' then the name will
2236:				; not be checked (get the first entry no matter what).
2237:				;
2238:15119+7	F8AB  0E00    	GETFST:	LD	C,0		;prepare for special search.
2239:15126+4	F8AD  EB      		EX	DE,HL
2240:15130+7	F8AE  7E      		LD	A,(HL)		;is first byte a '?'?
2241:15137+7	F8AF  FE3F    		CP	'?'
2242:15144+10	F8B1  CAC2F8  		JP	Z,GETFST1	;yes, just get very first entry (zero length match).
2243:15154+17	F8B4  CDA6F0  		CALL	SETEXT		;get the extension byte from fcb.
2244:15171+7	F8B7  7E      		LD	A,(HL)		;is it '?'? if yes, then we want
2245:15178+7	F8B8  FE3F    		CP	'?'		;an entry with a specific 's2' byte.
2246:15185+10+7	F8BA  C472F1  		CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
2247:15195+17	F8BD  CD51F8  		CALL	AUTOSEL		;select proper drive.
2248:15212+7	F8C0  0E0F    		LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
2249:15219+17	F8C2  CD18F3  	GETFST1:CALL	FINDFST		;find an entry and then move it into
2250:15236+10	F8C5  C3E9F1  		JP	MOVEDIR		;the users dma space.
2251:				;
2252:				;   Function to return the next occurence of a file name.
2253:				;
2254:15246+16	F8C8  2AD9F9  	GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
2255:15262+16	F8CB  2243EF  		LD	(PARAMS),HL	;other dbos calls are allowed.
2256:15278+17	F8CE  CD51F8  		CALL	AUTOSEL		;no error will be returned, but the
2257:15295+17	F8D1  CD2DF3  		CALL	FINDNXT		;results will be wrong.
2258:15312+10	F8D4  C3E9F1  		JP	MOVEDIR
2259:				;
2260:				;   Function to delete a file by name.
2261:				;
2262:15322+17	F8D7  CD51F8  	DELFILE:CALL	AUTOSEL		;select proper drive.
2263:15339+17	F8DA  CD9CF3  		CALL	ERAFILE		;erase the file.
2264:15356+10	F8DD  C301F3  		JP	STSTATUS	;set status and return.
2265:				;
2266:				;   Function to execute a sequential read of the specified
2267:				; record number.
2268:				;
2269:15366+17	F8E0  CD51F8  	READSEQ:CALL	AUTOSEL		;select proper drive then read.
2270:15383+10	F8E3  C3BCF5  		JP	RDSEQ
2271:				;
2272:				;   Function to write the net sequential record.
2273:				;
2274:15393+17	F8E6  CD51F8  	WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
2275:15410+10	F8E9  C3FEF5  		JP	WTSEQ
2276:				;
2277:				;   Create a file function.
2278:				;
2279:15420+17	F8EC  CD72F1  	FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
2280:15437+17	F8EF  CD51F8  		CALL	AUTOSEL		;select proper drive and get the next
2281:15454+10	F8F2  C324F5  		JP	GETEMPTY	;empty directory space.
2282:				;
2283:				;   Function to rename a file.
2284:				;
2285:15464+17	F8F5  CD51F8  	RENFILE:CALL	AUTOSEL		;select proper drive and then switch
2286:15481+17	F8F8  CD16F4  		CALL	CHGNAMES	;file names.
2287:15498+10	F8FB  C301F3  		JP	STSTATUS
2288:				;
2289:				;   Function to return the login vector.
2290:				;
2291:15508+16	F8FE  2AAFF9  	GETLOG:	LD	HL,(LOGIN)
2292:15524+10	F901  C329F9  		JP	GETPRM1
2293:				;
2294:				;   Function to return the current disk assignment.
2295:				;
2296:15534+13	F904  3A42EF  	GETCRNT:LD	A,(ACTIVE)
2297:15547+10	F907  C301EF  		JP	SETSTAT
2298:				;
2299:				;   Function to set the dma address.
2300:				;
2301:15557+4	F90A  EB      	PUTDMA:	EX	DE,HL
2302:15561+16	F90B  22B1F9  		LD	(USERDMA),HL	;save in our space and then get to
2303:15577+10	F90E  C3DAF1  		JP	DEFDMA		;the bios with this also.
2304:				;
2305:				;   Function to return the allocation vector.
2306:				;
2307:15587+16	F911  2ABFF9  	GETALOC:LD	HL,(ALOCVECT)
2308:15603+10	F914  C329F9  		JP	GETPRM1
2309:				;
2310:				;   Function to return the read-only status vector.
2311:				;
2312:15613+16	F917  2AADF9  	GETROV:	LD	HL,(WRTPRT)
2313:15629+10	F91A  C329F9  		JP	GETPRM1
2314:				;
2315:				;   Function to set the file attributes (read-only, system).
2316:				;
2317:15639+17	F91D  CD51F8  	SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
2318:15656+17	F920  CD3BF4  		CALL	SAVEATTR
2319:15673+10	F923  C301F3  		JP	STSTATUS
2320:				;
2321:				;   Function to return the address of the disk parameter block
2322:				; for the current drive.
2323:				;
2324:15683+16	F926  2ABBF9  	GETPARM:LD	HL,(DISKPB)
2325:15699+16	F929  2245EF  	GETPRM1:LD	(STATUS),HL
2326:15715+10	F92C  C9      		RET
2327:				;
2328:				;   Function to get or set the user number. If (E) was (FF)
2329:				; then this is a request to return the current user number.
2330:				; Else set the user number from (E).
2331:				;
2332:15725+13	F92D  3AD6F9  	GETUSER:LD	A,(EPARAM)	;get parameter.
2333:15738+7	F930  FEFF    		CP	0FFH		;get user number?
2334:15745+10	F932  C23BF9  		JP	NZ,SETUSER
2335:15755+13	F935  3A41EF  		LD	A,(USERNO)	;yes, just do it.
2336:15768+10	F938  C301EF  		JP	SETSTAT
2337:15778+7	F93B  E61F    	SETUSER:AND	1FH		;no, we should set it instead. keep low
2338:15785+13	F93D  3241EF  		LD	(USERNO),A	;bits (0-4) only.
2339:15798+10	F940  C9      		RET
2340:				;
2341:				;   Function to read a random record from a file.
2342:				;
2343:15808+17	F941  CD51F8  	RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
2344:15825+10	F944  C393F7  		JP	READRAN
2345:				;
2346:				;   Function to compute the file size for random files.
2347:				;
2348:15835+17	F947  CD51F8  	WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
2349:15852+10	F94A  C39CF7  		JP	WRITERAN
2350:				;
2351:				;   Function to compute the size of a random file.
2352:				;
2353:15862+17	F94D  CD51F8  	FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
2354:15879+10	F950  C3D2F7  		JP	RANSIZE
2355:				;
2356:				;   Function #37. This allows a program to log off any drives.
2357:				; On entry, set (DE) to contain a word with bits set for those
2358:				; drives that are to be logged off. The log-in vector and the
2359:				; write protect vector will be updated. This must be a M/PM
2360:				; special function.
2361:				;
2362:15889+16	F953  2A43EF  	LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
2363:15905+4	F956  7D      		LD	A,L		;for each bit that is set, we want
2364:15909+4	F957  2F      		CPL			;to clear that bit in (LOGIN)
2365:15913+4	F958  5F      		LD	E,A		;and (WRTPRT).
2366:15917+4	F959  7C      		LD	A,H
2367:15921+4	F95A  2F      		CPL
2368:15925+16	F95B  2AAFF9  		LD	HL,(LOGIN)	;reset the login vector.
2369:15941+4	F95E  A4      		AND	H
2370:15945+4	F95F  57      		LD	D,A
2371:15949+4	F960  7D      		LD	A,L
2372:15953+4	F961  A3      		AND	E
2373:15957+4	F962  5F      		LD	E,A
2374:15961+16	F963  2AADF9  		LD	HL,(WRTPRT)
2375:15977+4	F966  EB      		EX	DE,HL
2376:15981+16	F967  22AFF9  		LD	(LOGIN),HL	;and save.
2377:15997+4	F96A  7D      		LD	A,L		;now do the write protect vector.
2378:16001+4	F96B  A3      		AND	E
2379:16005+4	F96C  6F      		LD	L,A
2380:16009+4	F96D  7C      		LD	A,H
2381:16013+4	F96E  A2      		AND	D
2382:16017+4	F96F  67      		LD	H,A
2383:16021+16	F970  22ADF9  		LD	(WRTPRT),HL	;and save. all done.
2384:16037+10	F973  C9      		RET
2385:				;
2386:				;   Get here to return to the user.
2387:				;
2388:16047+13	F974  3ADEF9  	GOBACK:	LD	A,(AUTO)	;was auto select activated?
2389:16060+4	F977  B7      		OR	A
2390:16064+10	F978  CA91F9  		JP	Z,GOBACK1
2391:16074+16	F97B  2A43EF  		LD	HL,(PARAMS)	;yes, but was a change made?
2392:16090+10	F97E  3600    		LD	(HL),0		;(* reset first byte of fcb *)
2393:16100+13	F980  3AE0F9  		LD	A,(AUTOFLAG)
2394:16113+4	F983  B7      		OR	A
2395:16117+10	F984  CA91F9  		JP	Z,GOBACK1
2396:16127+7	F987  77      		LD	(HL),A		;yes, reset first byte properly.
2397:16134+13	F988  3ADFF9  		LD	A,(OLDDRV)	;and get the old drive and select it.
2398:16147+13	F98B  32D6F9  		LD	(EPARAM),A
2399:16160+17	F98E  CD45F8  		CALL	SETDSK
2400:16177+16	F991  2A0FEF  	GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
2401:16193+6	F994  F9      		LD	SP,HL
2402:16199+16	F995  2A45EF  		LD	HL,(STATUS)	;get return status.
2403:16215+4	F998  7D      		LD	A,L		;force version 1.4 compatability.
2404:16219+4	F999  44      		LD	B,H
2405:16223+10	F99A  C9      		RET			;and go back to user.
2406:				;
2407:				;   Function #40. This is a special entry to do random i/o.
2408:				; For the case where we are writing to unused disk space, this
2409:				; space will be zeroed out first. This must be a M/PM special
2410:				; purpose function, because why would any normal program even
2411:				; care about the previous contents of a sector about to be
2412:				; written over.
2413:				;
2414:16233+17	F99B  CD51F8  	WTSPECL:CALL	AUTOSEL		;select proper drive.
2415:16250+7	F99E  3E02    		LD	A,2		;use special write mode.
2416:16257+13	F9A0  32D5F9  		LD	(MODE),A
2417:16270+7	F9A3  0E00    		LD	C,0		;set write indicator.
2418:16277+17	F9A5  CD07F7  		CALL	POSITN1		;position the file.
2419:16294+10+7	F9A8  CC03F6  		CALL	Z,WTSEQ1	;and write (if no errors).
2420:16304+10	F9AB  C9      		RET
2421:				;
2422:				;**************************************************************
2423:				;*
2424:				;*     BDOS data storage pool.
2425:				;*
2426:				;**************************************************************
2427:				;
2428:     -	F9AC  E5      	EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
2429:     -	F9AD  0000    	WRTPRT:	DW	0		;write protect status for all 16 drives.
2430:     -	F9AF  0000    	LOGIN:	DW	0		;drive active word (1 bit per drive).
2431:     -	F9B1  8000    	USERDMA:DW	080H		;user's dma address (defaults to 80h).
2432:				;
2433:				;   Scratch areas from parameter block.
2434:				;
2435:     -	F9B3  0000    	SCRATCH1: DW	0		;relative position within dir segment for file (0-3).
2436:     -	F9B5  0000    	SCRATCH2: DW	0		;last selected track number.
2437:     -	F9B7  0000    	SCRATCH3: DW	0		;last selected sector number.
2438:				;
2439:				;   Disk storage areas from parameter block.
2440:				;
2441:     -	F9B9  0000    	DIRBUF:	DW	0		;address of directory buffer to use.
2442:     -	F9BB  0000    	DISKPB:	DW	0		;contains address of disk parameter block.
2443:     -	F9BD  0000    	CHKVECT:DW	0		;address of check vector.
2444:     -	F9BF  0000    	ALOCVECT: DW	0		;address of allocation vector (bit map).
2445:				;
2446:				;   Parameter block returned from the bios.
2447:				;
2448:     -	F9C1  0000    	SECTORS:DW	0		;sectors per track from bios.
2449:     -	F9C3  00      	BLKSHFT:DEFB	0		;block shift.
2450:     -	F9C4  00      	BLKMASK:DEFB	0		;block mask.
2451:     -	F9C5  00      	EXTMASK:DEFB	0		;extent mask.
2452:     -	F9C6  0000    	DSKSIZE:DW	0		;disk size from bios (number of blocks-1).
2453:     -	F9C8  0000    	DIRSIZE:DW	0		;directory size.
2454:     -	F9CA  0000    	ALLOC0:	DW	0		;storage for first bytes of bit map (dir space used).
2455:     -	F9CC  0000    	ALLOC1:	DW	0
2456:     -	F9CE  0000    	OFFSET:	DW	0		;first usable track number.
2457:     -	F9D0  0000    	XLATE:	DW	0		;sector translation table address.
2458:				;
2459:				;
2460:     -	F9D2  00      	CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
2461:     -	F9D3  00      	RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
2462:     -	F9D4  00      	FNDSTAT:DEFB	0		;filename found status (0=found first entry).
2463:     -	F9D5  00      	MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
2464:     -	F9D6  00      	EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
2465:     -	F9D7  00      	RELBLOCK: DEFB	0		;relative position within fcb of block number written.
2466:     -	F9D8  00      	COUNTER:DEFB	0		;byte counter for directory name searches.
2467:     -	F9D9  00000000	SAVEFCB:DW	0,0		;save space for address of fcb (for directory searches).
2468:     -	F9DD  00      	BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
2469:     -	F9DE  00      	AUTO:	DEFB	0		;if non-zero, then auto select activated.
2470:     -	F9DF  00      	OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
2471:     -	F9E0  00      	AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
2472:     -	F9E1  00      	SAVNXT:	DEFB	0		;storage for next record number to access.
2473:     -	F9E2  00      	SAVEXT:	DEFB	0		;storage for extent number of file.
2474:     -	F9E3  0000    	SAVNREC:DW	0		;storage for number of records in file.
2475:     -	F9E5  0000    	BLKNMBR:DW	0		;block number (physical sector) used within a file or logical sect
2476:     -	F9E7  0000    	LOGSECT:DW	0		;starting logical (128 byte) sector of block (physical sector).
2477:     -	F9E9  00      	FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
2478:     -	F9EA  0000    	FILEPOS:DW	0		;files position within directory (0 to max entries -1).
2479:				;
2480:				;   Disk directory buffer checksum bytes. One for each of the
2481:				; 16 possible drives.
2482:				;
2483:     -	F9EC  00000000	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	              00000000
	              00000000
	              00000000
2484:				;
2485:				;   Extra space ?
2486:				;
2487:     -	F9FC ..F9FF 00		DS	BIOS - $,0 ;	DEFB	0,0,0,0
2488:				
2489:     -	FA00          	_BDOSEND	equ $	
2490:     -	FA00          		END	;of CP/M 2.2



Statistics:

     4	passes
     0	jr promotions
   350	symbols
  3584	bytes

     1	macro calls
    26	macro bytes
     0	invented symbols



Symbol Table:

ACTIVE          EF42      61250
ADDA2HL         F164      61796
ALLOC0          F9CA      63946
ALLOC1          F9CC      63948
ALOCVECT        F9BF      63935
AUTO            F9DE      63966
AUTOFLAG        F9E0      63968
AUTOSEL         F851      63569
AUTOSL1         F875      63605
BACKUP          EDA4      60836
BACKUP1         EDAC      60844
BADSCTR         EC09      60425
BADSEC          ECCA      60618
BADSEL          ECD5      60629
BADSLCT         EC0B      60427
BDOS           =EC06      60422
BDOSDRV         ECC6      60614
BDOSERR         ECBA      60602
BIAS           =B000      45056
BIGDISK         F9DD      63965
BIOS           =FA00      64000
BITMAP          F2A3      62115
BITMAP1         F2B1      62129
BITMAP2         F2D2      62162
BITMAP3         F2F6      62198
BLKMASK         F9C4      63940
BLKNMBR         F9E5      63973
BLKSHFT         F9C3      63939
BOOT           =FA00      64000
BS             =08        8
CCP            =E400      58368
CDISK          =04        4
CHARBUF         EF0E      61198
CHECKDIR        F19E      61854
CHECKSUM        F0F7      61687
CHGNAM1         F427      62503
CHGNAMES        F416      62486
CHKBLK          F084      61572
CHKCHAR         ED14      60692
CHKDIR1         F1C4      61892
CHKNMBR         F18C      61836
CHKROFL         F144      61764
CHKSUM1         F0FD      61693
CHKVECT         F9BD      63933
CHKWPRT         F154      61780
CKBITMAP        F235      62005
CKBMAP1         F256      62038
CKCON1          ED42      60738
CKCON2          ED45      60741
CKCONSOL        ED23      60707
CKFILPOS        F1F5      61941
CKROF1          F147      61767
CKSUMTBL        F9EC      63980
CLEARS2         F172      61810
CLOSEFIL        F8A5      63653
CLOSEFLG        F9D2      63954
CLOSEIT         F4A2      62626
CLOSEIT1        F4CD      62669
CLOSEIT2        F4DB      62683
CLOSEIT3        F4E1      62689
CLOSEIT4        F4E8      62696
CLOSEIT5        F4FD      62717
CLOSEIT6        F517      62743
CLOSEIT7        F51F      62751
CNTRLC         =03        3
CNTRLE         =05        5
CNTRLP         =10        16
CNTRLR         =12        18
CNTRLS         =13        19
CNTRLU         =15        21
CNTRLX         =18        24
CNTRLZ         =1A        26
COMBLK          F077      61559
COMPRAND        F7A5      63397
CONIN          =FA09      64009
CONOUT         =FA0C      64012
CONST          =FA06      64006
COUNTER         F9D8      63960
CR             =0D        13
CURPOS          EF0C      61196
DE2HL           EF4F      61263
DE2HL1          EF50      61264
DEFDMA          F1DA      61914
DEL            =7F        127
DELFILE         F8D7      63703
DIRBUF          F9B9      63929
DIRC1           EEE0      61152
DIRCIO          EED4      61140
DIRDMA          F1E0      61920
DIRDMA1         F1E3      61923
DIRREAD         F1D4      61908
DIRSIZE         F9C8      63944
DIRWRITE        F1C6      61894
DISKPB          F9BB      63931
DISKRO          ECE1      60641
DOREAD          EFB2      61362
DOWRITE         EFB8      61368
DSKSIZE         F9C6      63942
EMPTYFCB        F9AC      63916
ENTRY          =05        5
EPARAM          F9D6      63958
ERAFIL1         F3A4      62372
ERAFILE         F39C      62364
ERROR1          EC99      60569
ERROR2          ECA5      60581
ERROR3          ECAB      60587
ERROR4          ECB1      60593
ERROR5          ECB4      60596
EXTBLK          F05E      61534
EXTBLK1         F071      61553
EXTMASK         F9C5      63941
FBASE           EC06      60422
FBASE1          EC11      60433
FCB2HL          F15E      61790
FCBPOS          F9E9      63977
FCBSET          F3FD      62461
FCREATE         F8EC      63724
FF             =0C        12
FILEPOS         F9EA      63978
FILERO          ECDC      60636
FILESIZE        F94D      63821
FINDFST         F318      62232
FINDNXT         F32D      62253
FNDNXT1         F34A      62282
FNDNXT2         F353      62291
FNDNXT3         F373      62323
FNDNXT4         F37C      62332
FNDNXT5         F383      62339
FNDNXT6         F394      62356
FNDSPA1         F3C0      62400
FNDSPA2         F3D1      62417
FNDSPA3         F3EC      62444
FNDSPA4         F3F4      62452
FNDSPACE        F3BE      62398
FNDSTAT         F9D4      63956
FUNCTNS         EC47      60487
GETALOC         F911      63761
GETBLK1         F045      61509
GETBLK2         F053      61523
GETBLK3         F05C      61532
GETBLOCK        F03E      61502
GETCHAR         ECFB      60667
GETCON          EEC8      61128
GETCRNT         F904      63748
GETCSTS         EEFE      61182
GETECHO         ED06      60678
GETEMPTY        F524      62756
GETFST          F8AB      63659
GETFST1         F8C2      63682
GETIOB          EEED      61165
GETLOG          F8FE      63742
GETMT1          F546      62790
GETNEXT         F55A      62810
GETNXT          F8C8      63688
GETPARM         F926      63782
GETPRM1         F929      63785
GETRDR          EECE      61134
GETROV          F917      63767
GETS2           F169      61801
GETUSER         F92D      63789
GETVER          F87E      63614
GETWPRT         F11E      61726
GOBACK          F974      63860
GOBACK1         F991      63889
GTNEXT1         F583      62851
GTNEXT2         F58E      62862
GTNEXT3         F5AC      62892
GTNEXT4         F5AF      62895
GTNEXT5         F5B6      62902
HOME           =FA18      64024
HOMEDRV         EFA1      61345
IOBYTE         =03        3
IOERR1          EF05      61189
IORET           EFBB      61371
JUMPHL          EF4A      61258
LF             =0A        10
LISTST         =FA2D      64045
LOGICAL         F08A      61578
LOGICL1         F090      61584
LOGIN           F9AF      63919
LOGINDRV        F821      63521
LOGOFF          F953      63827
LOGSECT         F9E7      63975
MEM            =40        64
MODE            F9D5      63957
MOREFLS         F17F      61823
MOVEDIR         F1E9      61929
MOVEWORD        F494      62612
NEWLINE         EDB1      60849
NEWLN1          EDB9      60857
NFUNCTS        =29        41
NXENT1          F219      61977
NXENT2          F220      61984
NXENTRY         F205      61957
OFFSET          F9CE      63950
OLDDRV          F9DF      63967
OPENFIL         F89C      63644
OPENIT          F451      62545
OPENIT1         F45A      62554
OPENIT2         F48B      62603
OUTCHAR         ED48      60744
OUTCHR1         ED62      60770
OUTCHR2         ED79      60793
OUTCON          ED90      60816
OUTCON1         ED96      60822
OUTCRLF         EDC9      60873
OUTFLAG         EF0A      61194
PARAMS          EF43      61251
PATTRN2         EC00      60416
PLIST          =FA0F      64015
POSITION        F703      63235
POSITN1         F707      63239
POSITN2         F747      63303
POSITN3         F77F      63359
POSITN4         F784      63364
POSITN5         F78B      63371
PRTERR          ECE5      60645
PRTFLAG         EF0D      61197
PRTMESG         EDD3      60883
PRTSTR          EEF8      61176
PUNCH          =FA12      64018
PUTDMA          F90A      63754
RANSIZ1         F7E4      63460
RANSIZ2         F806      63494
RANSIZ3         F80C      63500
RANSIZE         F7D2      63442
RDBUF1          EDEF      60911
RDBUF10         EE70      61040
RDBUF11         EE78      61048
RDBUF12         EE8A      61066
RDBUF13         EE99      61081
RDBUF14         EEA6      61094
RDBUF15         EEA9      61097
RDBUF16         EEBD      61117
RDBUF17         EEC1      61121
RDBUF2          EDF1      60913
RDBUF3          EE16      60950
RDBUF4          EE26      60966
RDBUF5          EE37      60983
RDBUF6          EE48      61000
RDBUF7          EE4E      61006
RDBUF8          EE5F      61023
RDBUF9          EE6B      61035
RDBUFF          EDE1      60897
RDRANDOM        F941      63809
RDSEQ           F5BC      62908
RDSEQ1          F5C1      62913
RDSEQ2          F5E6      62950
RDSEQ3          F5FB      62971
RDWRTFLG        F9D3      63955
READ           =FA27      64039
READER         =FA15      64021
READRAN         F793      63379
READSEQ         F8E0      63712
RELBLOCK        F9D7      63959
RENFILE         F8F5      63733
RODISK          EC0D      60429
ROFILE          EC0F      60431
RSTDSK          F883      63619
RTN             EF04      61188
SAMEXT          F307      62215
SAVATR1         F440      62528
SAVEATTR        F43B      62523
SAVEFCB         F9D9      63961
SAVEXT          F9E2      63970
SAVNREC         F9E3      63971
SAVNXT          F9E1      63969
SCRATCH1        F9B3      63923
SCRATCH2        F9B5      63925
SCRATCH3        F9B7      63927
SECTORS         F9C1      63937
SECTRN         =FA30      64048
SELDSK         =FA1B      64027
SELECT          EF59      61273
SELECT1         EF9D      61341
SETATTR         F91D      63773
SETBIT          F10B      61707
SETDIR          F19C      61852
SETDMA         =FA24      64036
SETDSK          F845      63557
SETEXT          F0A6      61606
SETFILE         F26B      62059
SETFL1          F275      62069
SETFL2          F288      62088
SETFL3          F28E      62094
SETFL4          F29D      62109
SETHLDE         F0AE      61614
SETIOB          EEF3      61171
SETNREC         F0D2      61650
SETRAN          F80E      63502
SETS2B7         F178      61816
SETSEC         =FA21      64033
SETSTAT         EF01      61185
SETTRK         =FA1E      64030
SETUSER         F93B      63803
SHIFTL          F104      61700
SHIFTL1         F105      61701
SHIFTR          F0EA      61674
SHIFTR1         F0EB      61675
SHOWIT          ED7F      60799
SLCTERR         EF47      61255
STARTING        EF0B      61195
STATUS          EF45      61253
STBITMAP        F25C      62044
STBMAP1         F264      62052
STFILPOS        F1FE      61950
STKAREA        =EF41      61249
STNREC1         F0DE      61662
STRDATA         F0BB      61627
STSTATUS        F301      62209
SUBHL           F195      61845
TAB            =09        9
TBASE          = 100      256
TBUFF          =80        128
TDRIVE         =04        4
TFCB           =5C        92
TRKSEC          EFC3      61379
TRKSEC1         EFD1      61393
TRKSEC2         EFE4      61412
TRKSEC3         EFFA      61434
TRKSEC4         F00F      61455
UPDATE          F401      62465
UPDATE1         F410      62480
USERDMA         F9B1      63921
USERNO          EF41      61249
USRSTACK        EF0F      61199
WBOOT          =FA03      64003
WRITE          =FA2A      64042
WRITERAN        F79C      63388
WRTPRT          F9AD      63917
WRTPRTD         F12C      61740
WRTSEQ          F8E6      63718
WTRANDOM        F947      63815
WTSEQ           F5FE      62974
WTSEQ1          F603      62979
WTSEQ10         F6D2      63186
WTSEQ11         F6FE      63230
WTSEQ12         F700      63232
WTSEQ2          F63B      63035
WTSEQ3          F648      63048
WTSEQ4          F664      63076
WTSEQ5          F66C      63084
WTSEQ6          F66E      63086
WTSEQ7          F68C      63116
WTSEQ8          F69A      63130
WTSEQ9          F6BB      63163
WTSEQ99         F6DF      63199
WTSPECL         F99B      63899
XLATE           F9D0      63952
_BDOSEND       =FA00      64000
