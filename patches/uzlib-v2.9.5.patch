From a37e5ef1e1132677af6e693b23efb4e595ec3a62 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=BCrgen=20Willi=20Sievers?= <JSievers@NadiSoft.de>
Date: Sat, 26 Aug 2023 20:03:32 +0200
Subject: [PATCH] ZiLOG Acclaim fixes

---
 README.md                              |  29 ++-
 examples/tgzip/tgzip.c                 |   8 +-
 patches/0001-ZiLOG-Acclaim-fixes.patch | 267 +++++++++++++++++++++++++
 src/defl_static.c                      |  11 +-
 src/defl_static.h                      |  18 +-
 src/genlz77.c                          |   2 +-
 src/tinflate.c                         |   5 +-
 src/uzlib.h                            |  16 +-
 8 files changed, 318 insertions(+), 38 deletions(-)
 create mode 100644 patches/0001-ZiLOG-Acclaim-fixes.patch

diff --git a/README.md b/README.md
index 4e09223..41dfa5d 100644
--- a/README.md
+++ b/README.md
@@ -72,16 +72,28 @@ Compressor features
 
 Compressor uses very basic implementation of LZ77 algorithm using hash
 table to find repeating substrings. The size of the hash table (on which
-compression efficiency depends) is currently hardcoded at the compile-time.
-Likewise, the size of LZ77 dictionary is also hardcoded at compile time.
-Both settings should be made runtime-configurable. The hash table is
-allocated on the stack, instead it should be allocated by user and passed
-as an argument to the function (dependency injection pattern).
+compression efficiency depends), pointer to the hashtable memory, and
+the size of LZ77 dictionary should be configured in `struct uzlib_comp`.
 
 Currently, compressor doesn't support streaming operation, both input and
 output must reside in memory. Neither it supports incremental operation,
 entire input buffer is compressed at once with a single call to uzlib.
 
+API and configuration
+---------------------
+
+The API is defined in the file [uzlib.h](src/uzlib.h) and should be largely
+self-describing. There are also examples implementing gzip-compatible
+compression and decompression applications in [examples/](examples/) for
+further reference. (You may also refer to the original `tinf` README
+below for additional information, but it's mostly provided for
+historical reference, and `uzlib` largely evolved beyond it).
+
+There are some compile-time options for the library, defined in
+the file [uzlib_conf.h](src/uzlib_conf.h). They can be altered directly
+in the file, or passed as the compiler options (`-DXXX=YYY`) when
+building library.
+
 Binary sizes
 ------------
 
@@ -114,8 +126,11 @@ arm-none-eabi-gcc (GNU Tools for Arm Embedded Processors 9-2019-q4-major) 9.2.1
 Original tinf library README
 ============================
 
-For reference, the original "tinf" library README follows. NOTE: Some
-parts may no longer apply to uzlib.
+*For historical reference and to provide proper credit, the original `tinf`
+library README follows. NOTE: Many parts no longer apply to `uzlib`. In
+particular, API is different, features supported are largely extended,
+and during decompression, there are checks to avoid erroneous/undefined
+behavior on incorrect Deflate bitstreams.*
 
 tinf - tiny inflate library
 ===========================
diff --git a/examples/tgzip/tgzip.c b/examples/tgzip/tgzip.c
index 505169c..d869d38 100644
--- a/examples/tgzip/tgzip.c
+++ b/examples/tgzip/tgzip.c
@@ -91,11 +91,11 @@ int main(int argc, char *argv[])
     comp.hash_table = malloc(hash_size);
     memset(comp.hash_table, 0, hash_size);
 
-    zlib_start_block(&comp.out);
+    zlib_start_block(&comp);
     uzlib_compress(&comp, source, len);
-    zlib_finish_block(&comp.out);
+    zlib_finish_block(&comp);
 
-    printf("compressed to %u raw bytes\n", comp.out.outlen);
+    printf("compressed to %u raw bytes\n", comp.outlen);
 
     /* -- write output -- */
 
@@ -108,7 +108,7 @@ int main(int argc, char *argv[])
     putc(0x04, fout); // XFL
     putc(0x03, fout); // OS
 
-    fwrite(comp.out.outbuf, 1, comp.out.outlen, fout);
+    fwrite(comp.outbuf, 1, comp.outlen, fout);
 
     unsigned crc = ~uzlib_crc32(source, len, ~0);
     fwrite(&crc, sizeof(crc), 1, fout);
diff --git a/patches/0001-ZiLOG-Acclaim-fixes.patch b/patches/0001-ZiLOG-Acclaim-fixes.patch
new file mode 100644
index 0000000..3470a55
--- /dev/null
+++ b/patches/0001-ZiLOG-Acclaim-fixes.patch
@@ -0,0 +1,267 @@
+From 45e417d9a28424d825ef053d73af3a4623c6fa9b Mon Sep 17 00:00:00 2001
+Message-ID: <45e417d9a28424d825ef053d73af3a4623c6fa9b.1693073061.git.JSievers@NadiSoft.de>
+From: =?UTF-8?q?J=C3=BCrgen=20Willi=20Sievers?= <JSievers@NadiSoft.de>
+Date: Sat, 26 Aug 2023 20:03:32 +0200
+Subject: [PATCH] ZiLOG Acclaim fixes
+
+---
+ README.md              | 29 ++++++++++++++++++++++-------
+ examples/tgzip/tgzip.c |  8 ++++----
+ src/defl_static.c      | 11 ++++++-----
+ src/defl_static.h      | 18 +++++-------------
+ src/genlz77.c          |  2 +-
+ src/tinflate.c         |  5 +++--
+ src/uzlib.h            | 16 ++++++++++------
+ 7 files changed, 51 insertions(+), 38 deletions(-)
+
+diff --git a/README.md b/README.md
+index 4e09223..41dfa5d 100644
+--- a/README.md
++++ b/README.md
+@@ -72,16 +72,28 @@ Compressor features
+ 
+ Compressor uses very basic implementation of LZ77 algorithm using hash
+ table to find repeating substrings. The size of the hash table (on which
+-compression efficiency depends) is currently hardcoded at the compile-time.
+-Likewise, the size of LZ77 dictionary is also hardcoded at compile time.
+-Both settings should be made runtime-configurable. The hash table is
+-allocated on the stack, instead it should be allocated by user and passed
+-as an argument to the function (dependency injection pattern).
++compression efficiency depends), pointer to the hashtable memory, and
++the size of LZ77 dictionary should be configured in `struct uzlib_comp`.
+ 
+ Currently, compressor doesn't support streaming operation, both input and
+ output must reside in memory. Neither it supports incremental operation,
+ entire input buffer is compressed at once with a single call to uzlib.
+ 
++API and configuration
++---------------------
++
++The API is defined in the file [uzlib.h](src/uzlib.h) and should be largely
++self-describing. There are also examples implementing gzip-compatible
++compression and decompression applications in [examples/](examples/) for
++further reference. (You may also refer to the original `tinf` README
++below for additional information, but it's mostly provided for
++historical reference, and `uzlib` largely evolved beyond it).
++
++There are some compile-time options for the library, defined in
++the file [uzlib_conf.h](src/uzlib_conf.h). They can be altered directly
++in the file, or passed as the compiler options (`-DXXX=YYY`) when
++building library.
++
+ Binary sizes
+ ------------
+ 
+@@ -114,8 +126,11 @@ arm-none-eabi-gcc (GNU Tools for Arm Embedded Processors 9-2019-q4-major) 9.2.1
+ Original tinf library README
+ ============================
+ 
+-For reference, the original "tinf" library README follows. NOTE: Some
+-parts may no longer apply to uzlib.
++*For historical reference and to provide proper credit, the original `tinf`
++library README follows. NOTE: Many parts no longer apply to `uzlib`. In
++particular, API is different, features supported are largely extended,
++and during decompression, there are checks to avoid erroneous/undefined
++behavior on incorrect Deflate bitstreams.*
+ 
+ tinf - tiny inflate library
+ ===========================
+diff --git a/examples/tgzip/tgzip.c b/examples/tgzip/tgzip.c
+index 505169c..d869d38 100644
+--- a/examples/tgzip/tgzip.c
++++ b/examples/tgzip/tgzip.c
+@@ -91,11 +91,11 @@ int main(int argc, char *argv[])
+     comp.hash_table = malloc(hash_size);
+     memset(comp.hash_table, 0, hash_size);
+ 
+-    zlib_start_block(&comp.out);
++    zlib_start_block(&comp);
+     uzlib_compress(&comp, source, len);
+-    zlib_finish_block(&comp.out);
++    zlib_finish_block(&comp);
+ 
+-    printf("compressed to %u raw bytes\n", comp.out.outlen);
++    printf("compressed to %u raw bytes\n", comp.outlen);
+ 
+     /* -- write output -- */
+ 
+@@ -108,7 +108,7 @@ int main(int argc, char *argv[])
+     putc(0x04, fout); // XFL
+     putc(0x03, fout); // OS
+ 
+-    fwrite(comp.out.outbuf, 1, comp.out.outlen, fout);
++    fwrite(comp.outbuf, 1, comp.outlen, fout);
+ 
+     unsigned crc = ~uzlib_crc32(source, len, ~0);
+     fwrite(&crc, sizeof(crc), 1, fout);
+diff --git a/src/defl_static.c b/src/defl_static.c
+index 522d485..d6578b2 100644
+--- a/src/defl_static.c
++++ b/src/defl_static.c
+@@ -34,6 +34,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ #include <stdint.h>
+ #include <string.h>
+ #include <assert.h>
++#include "uzlib.h"
+ #include "defl_static.h"
+ 
+ #define snew(type) ( (type *) malloc(sizeof(type)) )
+@@ -60,7 +61,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+  * having to transmit the trees.
+  */
+ 
+-void outbits(struct Outbuf *out, unsigned long bits, int nbits)
++void outbits(struct uzlib_comp *out, unsigned long bits, int nbits)
+ {
+     assert(out->noutbits + nbits <= 32);
+     out->outbits |= bits << out->noutbits;
+@@ -189,7 +190,7 @@ static const dist_coderecord distcodes[] = {
+     {29, 13, 24577, 32768},
+ };
+ 
+-void zlib_literal(struct Outbuf *out, unsigned char c)
++void zlib_literal(struct uzlib_comp *out, unsigned char c)
+ {
+     if (out->comp_disabled) {
+         /*
+@@ -208,7 +209,7 @@ void zlib_literal(struct Outbuf *out, unsigned char c)
+     }
+ }
+ 
+-void zlib_match(struct Outbuf *out, int distance, int len)
++void zlib_match(struct uzlib_comp *out, int distance, int len)
+ {
+     const dist_coderecord *d;
+     const len_coderecord *l;
+@@ -303,14 +304,14 @@ void zlib_match(struct Outbuf *out, int distance, int len)
+     }
+ }
+ 
+-void zlib_start_block(struct Outbuf *out)
++void zlib_start_block(struct uzlib_comp *out)
+ {
+ //    outbits(out, 0x9C78, 16);
+     outbits(out, 1, 1); /* Final block */
+     outbits(out, 1, 2); /* Static huffman block */
+ }
+ 
+-void zlib_finish_block(struct Outbuf *out)
++void zlib_finish_block(struct uzlib_comp *out)
+ {
+     outbits(out, 0, 7); /* close block */
+     outbits(out, 0, 7); /* Make sure all bits are flushed */
+diff --git a/src/defl_static.h b/src/defl_static.h
+index 292734d..cdfa973 100644
+--- a/src/defl_static.h
++++ b/src/defl_static.h
+@@ -30,16 +30,8 @@
+    They may be altered/distinct from the originals used in PuTTY source
+    code. */
+ 
+-struct Outbuf {
+-    unsigned char *outbuf;
+-    int outlen, outsize;
+-    unsigned long outbits;
+-    int noutbits;
+-    int comp_disabled;
+-};
+-
+-void outbits(struct Outbuf *out, unsigned long bits, int nbits);
+-void zlib_start_block(struct Outbuf *ctx);
+-void zlib_finish_block(struct Outbuf *ctx);
+-void zlib_literal(struct Outbuf *ectx, unsigned char c);
+-void zlib_match(struct Outbuf *ectx, int distance, int len);
++void outbits(struct uzlib_comp *ctx, unsigned long bits, int nbits);
++void zlib_start_block(struct uzlib_comp *ctx);
++void zlib_finish_block(struct uzlib_comp *ctx);
++void zlib_literal(struct uzlib_comp *ctx, unsigned char c);
++void zlib_match(struct uzlib_comp *ctx, int distance, int len);
+diff --git a/src/genlz77.c b/src/genlz77.c
+index ede1fc9..4bf07ae 100644
+--- a/src/genlz77.c
++++ b/src/genlz77.c
+@@ -104,9 +104,9 @@ void uzlib_compress(struct uzlib_comp *data, const uint8_t *src, unsigned slen)
+         const uint8_t *subs = *bucket;
+         *bucket = src;
+         if (subs && src > subs && (src - subs) <= MAX_OFFSET && !memcmp(src, subs, MIN_MATCH)) {
+-            src += MIN_MATCH;
+             const uint8_t *m = subs + MIN_MATCH;
+             int len = MIN_MATCH;
++            src += MIN_MATCH;
+             while (*src == *m && len < MAX_MATCH && src < top) {
+                 src++; m++; len++;
+             }
+diff --git a/src/tinflate.c b/src/tinflate.c
+index d719d80..1cb6cf9 100644
+--- a/src/tinflate.c
++++ b/src/tinflate.c
+@@ -500,7 +500,8 @@ static int tinf_inflate_block_data(TINF_DATA *d, TINF_TREE *lt, TINF_TREE *dt)
+ 
+ /* inflate next byte from uncompressed block of data */
+ static int tinf_inflate_uncompressed_block(TINF_DATA *d)
+-{
++{    
++	unsigned char c;
+     if (d->curlen == 0) {
+         unsigned int length, invlength;
+ 
+@@ -525,7 +526,7 @@ static int tinf_inflate_uncompressed_block(TINF_DATA *d)
+         return TINF_DONE;
+     }
+ 
+-    unsigned char c = uzlib_get_byte(d);
++	c = uzlib_get_byte(d);
+     TINF_PUT(d, c);
+     return TINF_OK;
+ }
+diff --git a/src/uzlib.h b/src/uzlib.h
+index 3a4a1ad..681ad74 100644
+--- a/src/uzlib.h
++++ b/src/uzlib.h
+@@ -39,7 +39,9 @@
+ #include <stdint.h>
+ #include <stdbool.h>
+ 
+-#include "defl_static.h"
++#ifdef __cplusplus
++extern "C" {
++#endif
+ 
+ #include "uzlib_conf.h"
+ #if UZLIB_CONF_DEBUG_LOG
+@@ -55,10 +57,6 @@
+  #endif
+ #endif
+ 
+-#ifdef __cplusplus
+-extern "C" {
+-#endif
+-
+ /* ok status, more data produced */
+ #define TINF_OK             0
+ /* end of compressed stream reached */
+@@ -146,7 +144,11 @@ int TINFCC uzlib_gzip_parse_header(TINF_DATA *d);
+ typedef const uint8_t *uzlib_hash_entry_t;
+ 
+ struct uzlib_comp {
+-    struct Outbuf out;
++    unsigned char *outbuf;
++    int outlen, outsize;
++    unsigned long outbits;
++    int noutbits;
++    int comp_disabled;
+ 
+     uzlib_hash_entry_t *hash_table;
+     unsigned int hash_bits;
+@@ -155,6 +157,8 @@ struct uzlib_comp {
+ 
+ void TINFCC uzlib_compress(struct uzlib_comp *c, const uint8_t *src, unsigned slen);
+ 
++#include "defl_static.h"
++
+ /* Checksum API */
+ 
+ /* prev_sum is previous value for incremental computation, 1 initially */
+-- 
+2.41.0
+
diff --git a/src/defl_static.c b/src/defl_static.c
index 522d485..d6578b2 100644
--- a/src/defl_static.c
+++ b/src/defl_static.c
@@ -34,6 +34,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <stdint.h>
 #include <string.h>
 #include <assert.h>
+#include "uzlib.h"
 #include "defl_static.h"
 
 #define snew(type) ( (type *) malloc(sizeof(type)) )
@@ -60,7 +61,7 @@ WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  * having to transmit the trees.
  */
 
-void outbits(struct Outbuf *out, unsigned long bits, int nbits)
+void outbits(struct uzlib_comp *out, unsigned long bits, int nbits)
 {
     assert(out->noutbits + nbits <= 32);
     out->outbits |= bits << out->noutbits;
@@ -189,7 +190,7 @@ static const dist_coderecord distcodes[] = {
     {29, 13, 24577, 32768},
 };
 
-void zlib_literal(struct Outbuf *out, unsigned char c)
+void zlib_literal(struct uzlib_comp *out, unsigned char c)
 {
     if (out->comp_disabled) {
         /*
@@ -208,7 +209,7 @@ void zlib_literal(struct Outbuf *out, unsigned char c)
     }
 }
 
-void zlib_match(struct Outbuf *out, int distance, int len)
+void zlib_match(struct uzlib_comp *out, int distance, int len)
 {
     const dist_coderecord *d;
     const len_coderecord *l;
@@ -303,14 +304,14 @@ void zlib_match(struct Outbuf *out, int distance, int len)
     }
 }
 
-void zlib_start_block(struct Outbuf *out)
+void zlib_start_block(struct uzlib_comp *out)
 {
 //    outbits(out, 0x9C78, 16);
     outbits(out, 1, 1); /* Final block */
     outbits(out, 1, 2); /* Static huffman block */
 }
 
-void zlib_finish_block(struct Outbuf *out)
+void zlib_finish_block(struct uzlib_comp *out)
 {
     outbits(out, 0, 7); /* close block */
     outbits(out, 0, 7); /* Make sure all bits are flushed */
diff --git a/src/defl_static.h b/src/defl_static.h
index 292734d..cdfa973 100644
--- a/src/defl_static.h
+++ b/src/defl_static.h
@@ -30,16 +30,8 @@
    They may be altered/distinct from the originals used in PuTTY source
    code. */
 
-struct Outbuf {
-    unsigned char *outbuf;
-    int outlen, outsize;
-    unsigned long outbits;
-    int noutbits;
-    int comp_disabled;
-};
-
-void outbits(struct Outbuf *out, unsigned long bits, int nbits);
-void zlib_start_block(struct Outbuf *ctx);
-void zlib_finish_block(struct Outbuf *ctx);
-void zlib_literal(struct Outbuf *ectx, unsigned char c);
-void zlib_match(struct Outbuf *ectx, int distance, int len);
+void outbits(struct uzlib_comp *ctx, unsigned long bits, int nbits);
+void zlib_start_block(struct uzlib_comp *ctx);
+void zlib_finish_block(struct uzlib_comp *ctx);
+void zlib_literal(struct uzlib_comp *ctx, unsigned char c);
+void zlib_match(struct uzlib_comp *ctx, int distance, int len);
diff --git a/src/genlz77.c b/src/genlz77.c
index ede1fc9..4bf07ae 100644
--- a/src/genlz77.c
+++ b/src/genlz77.c
@@ -104,9 +104,9 @@ void uzlib_compress(struct uzlib_comp *data, const uint8_t *src, unsigned slen)
         const uint8_t *subs = *bucket;
         *bucket = src;
         if (subs && src > subs && (src - subs) <= MAX_OFFSET && !memcmp(src, subs, MIN_MATCH)) {
-            src += MIN_MATCH;
             const uint8_t *m = subs + MIN_MATCH;
             int len = MIN_MATCH;
+            src += MIN_MATCH;
             while (*src == *m && len < MAX_MATCH && src < top) {
                 src++; m++; len++;
             }
diff --git a/src/tinflate.c b/src/tinflate.c
index d719d80..1cb6cf9 100644
--- a/src/tinflate.c
+++ b/src/tinflate.c
@@ -500,7 +500,8 @@ static int tinf_inflate_block_data(TINF_DATA *d, TINF_TREE *lt, TINF_TREE *dt)
 
 /* inflate next byte from uncompressed block of data */
 static int tinf_inflate_uncompressed_block(TINF_DATA *d)
-{
+{    
+	unsigned char c;
     if (d->curlen == 0) {
         unsigned int length, invlength;
 
@@ -525,7 +526,7 @@ static int tinf_inflate_uncompressed_block(TINF_DATA *d)
         return TINF_DONE;
     }
 
-    unsigned char c = uzlib_get_byte(d);
+	c = uzlib_get_byte(d);
     TINF_PUT(d, c);
     return TINF_OK;
 }
diff --git a/src/uzlib.h b/src/uzlib.h
index 3a4a1ad..681ad74 100644
--- a/src/uzlib.h
+++ b/src/uzlib.h
@@ -39,7 +39,9 @@
 #include <stdint.h>
 #include <stdbool.h>
 
-#include "defl_static.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
 
 #include "uzlib_conf.h"
 #if UZLIB_CONF_DEBUG_LOG
@@ -55,10 +57,6 @@
  #endif
 #endif
 
-#ifdef __cplusplus
-extern "C" {
-#endif
-
 /* ok status, more data produced */
 #define TINF_OK             0
 /* end of compressed stream reached */
@@ -146,7 +144,11 @@ int TINFCC uzlib_gzip_parse_header(TINF_DATA *d);
 typedef const uint8_t *uzlib_hash_entry_t;
 
 struct uzlib_comp {
-    struct Outbuf out;
+    unsigned char *outbuf;
+    int outlen, outsize;
+    unsigned long outbits;
+    int noutbits;
+    int comp_disabled;
 
     uzlib_hash_entry_t *hash_table;
     unsigned int hash_bits;
@@ -155,6 +157,8 @@ struct uzlib_comp {
 
 void TINFCC uzlib_compress(struct uzlib_comp *c, const uint8_t *src, unsigned slen);
 
+#include "defl_static.h"
+
 /* Checksum API */
 
 /* prev_sum is previous value for incremental computation, 1 initially */
-- 
2.41.0

